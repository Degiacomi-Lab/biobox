
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Examples &#8212; biobox 1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/classic.css" />
    
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Measures" href="measures.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="measures.html" title="Measures"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">biobox 1.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Examples</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="examples">
<h1>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h1>
<section id="selecting-atoms-from-a-multi-pdb">
<h2>Selecting atoms from a (multi)PDB<a class="headerlink" href="#selecting-atoms-from-a-multi-pdb" title="Permalink to this headline">¶</a></h2>
<p>Let’s load a molecule, and identify only the backbone atoms of chain A.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">biobox</span><span class="o">.</span><span class="n">Molecule</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">import_pdb</span><span class="p">(</span><span class="s2">&quot;protein.pdb&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">atomselect</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;CA&quot;</span><span class="p">,</span><span class="s2">&quot;C&quot;</span><span class="p">,</span><span class="s2">&quot;N&quot;</span><span class="p">,</span><span class="s2">&quot;O&quot;</span><span class="p">],</span> <span class="n">get_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="structure.html#molecule.Molecule.atomselect" title="molecule.Molecule.atomselect"><code class="xref py py-func docutils literal notranslate"><span class="pre">atomselect</span></code></a> accepts as parameters single strings, lists or “*” as wildcard.
After this call, pos contains the coordinates of all selected atoms, and idx their indices.
Another way to select atoms, is to use the <a class="reference internal" href="structure.html#molecule.Molecule.query" title="molecule.Molecule.query"><code class="xref py py-func docutils literal notranslate"><span class="pre">atomselect</span></code></a> method. The following call will yield the same result as the atomselect above.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pos</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s1">&#39;chain == &quot;A&quot; and name == [&quot;CA&quot;,&quot;C&quot;,&quot;N&quot;,&quot;O&quot;]&#39;</span><span class="p">,</span> <span class="n">get_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The query methods follows the pandas query syntax, and allows to be more expressive. Any column stored in M.data (call M.data.columns) can be addressed.
Now that we have identified indices of interest, we can save a subset of the initial pdb in a new one, or to create a new <a class="reference internal" href="structure.html#molecule.Molecule" title="molecule.Molecule"><code class="xref py py-func docutils literal notranslate"><span class="pre">Molecule</span></code></a> object containing only them.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">write_pdb</span><span class="p">(</span><span class="s2">&quot;chainA.pdb&quot;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">idx</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M2</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">get_subset</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>multiple conformations</strong> may be available in the PDB. By default, the first one is set as current.
Is is possible to set as current another one as follows:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">set_current</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos2</span><span class="p">,</span> <span class="n">idx2</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">atomselect</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;CA&quot;</span><span class="p">,</span><span class="s2">&quot;C&quot;</span><span class="p">,</span><span class="s2">&quot;N&quot;</span><span class="p">,</span><span class="s2">&quot;O&quot;</span><span class="p">],</span> <span class="n">get_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>After this new <a class="reference internal" href="structure.html#molecule.Molecule.atomselect" title="molecule.Molecule.atomselect"><code class="xref py py-func docutils literal notranslate"><span class="pre">atomselect</span></code></a> call, idx2 will be equal to idx1 (atom selected are still the same), but pos2 will be different from pos (atoms positions differ between different conformations).
Unless otherwise specified, <a class="reference internal" href="structure.html#molecule.Molecule.get_subset" title="molecule.Molecule.get_subset"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_subset</span></code></a> selects all the alternative conformations from the atoms of interest.
<a class="reference internal" href="structure.html#molecule.Molecule.get_subset" title="molecule.Molecule.get_subset"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_subset</span></code></a> can however also be instructed to select a subset of conformations, for instance:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M2</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">get_subset</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">conformations</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
<p>This call will select only the conformations 0, 1 and 2 of atoms of interest.</p>
</section>
<section id="protein-conformations-clustering">
<h2>protein conformations clustering<a class="headerlink" href="#protein-conformations-clustering" title="Permalink to this headline">¶</a></h2>
<p>Suppose you have several PDB files of the same protein (same number of atoms), and you want to cluster them according to a hierarchical clustering.
We can for example add the coordinates of all pdb files to the same <a class="reference internal" href="structure.html#molecule.Molecule" title="molecule.Molecule"><code class="xref py py-func docutils literal notranslate"><span class="pre">Molecule</span></code></a> instance (supposing that they all have the same amount of atoms):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">glob</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">files</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s2">&quot;*pdb&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">biobox</span><span class="o">.</span><span class="n">Molecule</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">import_pdb</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">files</span><span class="p">)):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">M2</span> <span class="o">=</span> <span class="n">Molecule</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">M2</span><span class="o">.</span><span class="n">import_pdb</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">M2_xyz</span> <span class="o">=</span> <span class="n">M2</span><span class="o">.</span><span class="n">get_xyz</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">M</span><span class="o">.</span><span class="n">add_xyz</span><span class="p">(</span><span class="n">M2_xyz</span><span class="p">)</span>
</pre></div>
</div>
<p>In order to generate a hierarchical clustering of these conformations, we need a flattened RMSD distance matrix.
This can then be fed to scipy’s Nearest Point Algorithm for clustering.
In this example, we will aggregate all structures having and RMSD smaller than 2 Angstrom.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">scipy.cluster.hierarchy</span> <span class="k">as</span> <span class="nn">SCH</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dist</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">rmsd_distance_matrix</span><span class="p">(</span><span class="n">flat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hierarchic_cluster</span> <span class="o">=</span> <span class="n">SCH</span><span class="o">.</span><span class="n">linkage</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;single&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flat_clusters</span> <span class="o">=</span> <span class="n">SCH</span><span class="o">.</span><span class="n">fcluster</span><span class="p">(</span><span class="n">hierarchic_cluster</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">criterion</span><span class="o">=</span><span class="s1">&#39;distance&#39;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="protein-polyhedral-assemblies">
<h2>protein polyhedral assemblies<a class="headerlink" href="#protein-polyhedral-assemblies" title="Permalink to this headline">¶</a></h2>
<p>We want to produce several protein tetrahedral assemblies, and compare them to each other.
First, let’s load our protein building block:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">biobox</span><span class="o">.</span><span class="n">Molecule</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">import_pdb</span><span class="p">(</span><span class="s2">&quot;protein.pdb&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Now, let’s create a <a class="reference internal" href="assembly.html#multimer.Multimer" title="multimer.Multimer"><code class="xref py py-func docutils literal notranslate"><span class="pre">Multimer</span></code></a> arranged according to a tetrahedral symmetry.
To do so, we have to load information about the tetrahedral scaffold BiobOx will exploit to align six monomers.
By default this information is stored in the file classes/polyhedron_database.dat, though the user can import his own database.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">biobox</span><span class="o">.</span><span class="n">Multimer</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span><span class="o">.</span><span class="n">setup_polyhedron</span><span class="p">(</span><span class="s1">&#39;Tetrahedron&#39;</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span><span class="o">.</span><span class="n">generate_polyhedron</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">180</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>Now, P contains six proteins arranged as a tetrahedron having a radius of 10 Angstrom.
Every subunit is rotated with respect of its specific position on the scaffold.
Rotation angles are defined with respect of the molecule’s principal axes.
Here, we rotate by 180 degrees around the first principal axis, 20 around the second, and 10 around the third.
Let’s now build two new polyhedra with different radii and rotation angles:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">P</span><span class="o">.</span><span class="n">generate_polyhedron</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">180</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">65</span><span class="p">,</span> <span class="n">add_conformation</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span><span class="o">.</span><span class="n">generate_polyhedron</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">185</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">60</span><span class="p">,</span> <span class="n">add_conformation</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Since we set add_conformation=True, the atoms arrangement of the new multimers will be appended as new conformations.
With add_conformation=False (default) the previous subunits arrangements gets overwritten.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>assemblies’ multiple conformations are treated by appending on each subunit its different conformation. BiobOx then sets on all subunits the same current position.</p>
</div>
<p>Now, we want to calculate the RMSD between the created multimers’ alpha carbons. With these lines, dist_mat will contain the RMSD distance matrix between the multimers:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">idxs</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">atomselect</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span> <span class="p">,</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="s2">&quot;CA&quot;</span><span class="p">,</span> <span class="n">get_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dist_mat</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">rmsd_distance_matrix</span><span class="p">(</span><span class="n">points_indices</span><span class="o">=</span><span class="n">idxs</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that, as for the case of <a class="reference internal" href="structure.html#molecule.Molecule" title="molecule.Molecule"><code class="xref py py-func docutils literal notranslate"><span class="pre">atomselect</span></code></a> objects, a <code class="xref py py-func docutils literal notranslate"><span class="pre">query</span></code> method is also available. The same selection as the command above can be obtained with:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s1">&#39;name == &quot;CA&quot;&#39;</span><span class="p">,</span> <span class="n">get_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>To select atoms from some specific units, the following command can be issued:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s1">&#39;unit == [&quot;0&quot;, &quot;3&quot;, &quot;5&quot;] and name == &quot;CA&quot;&#39;</span><span class="p">,</span> <span class="n">get_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>Subunits can also be grouped, and different groups can be rotated differently.
In the following example, the tetrahedron’s chains A, B, C and D, E, F form different groups that are rotated independently.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span><span class="o">.</span><span class="n">conn_type</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span><span class="o">.</span><span class="n">generate_polyhedron</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">90</span><span class="p">,</span><span class="mi">180</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]))</span>
</pre></div>
</div>
<p>Note that when more than one edge type is provided, rotation angles should be in the form of a numpy array having the same length as the amount of different groups in connection (values in conn_type are used to index the angles arrays).</p>
<p>Polyhedral scaffolds are constituted of vertices connected by edges.
By altering the position of the vertices, the scaffolds can be deformed (e.g. useful to model near-symmetries).
In BiobOx, deformations are treated in terms of deformation vectors, i.e. unit-vectors indicating in which direction a vertex can move.
Here, we will allow the first vertex to move radially. We will then build a tetrahedron, where this vertex is displaced from its initial position by its deformation vector, scaled by a constant (here, 5).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">P</span><span class="o">.</span><span class="n">add_deformation</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span><span class="o">.</span><span class="n">generate_polyhedron</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">90</span><span class="p">,</span><span class="mi">180</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span> <span class="n">deformation</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
</pre></div>
</div>
<p>Note that <a class="reference internal" href="assembly.html#polyhedron.Polyhedron.add_deformation" title="polyhedron.Polyhedron.add_deformation"><code class="xref py py-func docutils literal notranslate"><span class="pre">add_deformation</span></code></a> also accepts user-defined deformation vectors.
To see how your scaffold looks like, a pdb file containing the vertices and an associated TCL script for <a class="reference external" href="http://www.ks.uiuc.edu/Research/vmd">VMD</a> (drawing colored edges, as a function of grouping) can be produced.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">P</span><span class="o">.</span><span class="n">write_poly_architecture</span><span class="p">(</span><span class="s2">&quot;architecture&quot;</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">deformation</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
</pre></div>
</div>
<p>This will generate two files architecture.pdb and architecture.tcl.
The initial unit-sized scaffold will scaled by 10, and the first vertex moved away radially.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>this method was used to build polyhedral assemblies consistent with experimental data in <a class="reference external" href="https://www.jbc.org/content/293/51/19511.long">I. Santhanagopalan I. et al., It takes a dimer to tango: Oligomeric small heat shock proteins dissociate to capture substrate, Journal of Biological Chemisty, 2018</a></p>
</div>
</section>
<section id="super-coarse-grain-modelling">
<h2>super coarse-grain modelling<a class="headerlink" href="#super-coarse-grain-modelling" title="Permalink to this headline">¶</a></h2>
<p>In this example, we will arrange a group of cylinders in a ring.
To do so, we have first to create a single collection of points arranged like a <a class="reference internal" href="structure.html#convex.Cylinder" title="convex.Cylinder"><code class="xref py py-func docutils literal notranslate"><span class="pre">Cylinder</span></code></a>.
Unless otherwise specified (using the optional keyword radius), every point composing the cylinder (and any other convex point cloud) will have a radius of 1.4 Angstrom.
To simulate a smooth surface, one can either increase the points radius, or their density.
Here, we will use default values, and the resulting cylinder will then be rotated by 45 degrees along the x axis.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cylinder_length</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cylinder_radius</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">biobox</span><span class="o">.</span><span class="n">Cylinder</span><span class="p">(</span><span class="n">cylinder_length</span><span class="p">,</span> <span class="n">cylinder_radius</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="mi">45</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>We will now create an assembly loading ten copies of our template cylinder, arrange them in a 30 Angstrom-wide circle, and save the resulting structure into a PDB file.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">biobox</span><span class="o">.</span><span class="n">Assembly</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">make_circular_symmetry</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">write_pdb</span><span class="p">(</span><span class="s2">&quot;assembly.pdb&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>We can now assess some of the assembly’s characteristics, for instance its height and width.
This can be done by extracting all the assembly’s points coordinates in a unique numpy array.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xyz</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">get_all_xyz</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">xyz</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">xyz</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">height</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">xyz</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">xyz</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
<p>An alternative way to measure assembly dimensions, it to profit of methods in <a class="reference internal" href="structure.html#structure.Structure" title="structure.Structure"><code class="xref py py-func docutils literal notranslate"><span class="pre">Structure</span></code></a> class.
Here we collapse the Assembly’s units coordinates in a single <a class="reference internal" href="structure.html#structure.Structure" title="structure.Structure"><code class="xref py py-func docutils literal notranslate"><span class="pre">Structure</span></code></a> instance.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">make_structure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">S</span><span class="o">.</span><span class="n">get_size</span><span class="p">()</span>
</pre></div>
</div>
<p>In case not all the subunits of the assembly are the same, a list of subunits can be loaded.
In this case, we will load a <a class="reference internal" href="structure.html#convex.Sphere" title="convex.Sphere"><code class="xref py py-func docutils literal notranslate"><span class="pre">Sphere</span></code></a> (and call it “S”) as well as two identical cylinders (called “C1” and “C2”).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sphere_radius</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cylinder_radius</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cylinder_length</span> <span class="o">=</span> <span class="mi">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">biobox</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="n">sphere_radius</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">biobox</span><span class="o">.</span><span class="n">Cylinder</span><span class="p">(</span><span class="n">cylinder_radius</span><span class="p">,</span> <span class="n">cylinder_length</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A2</span> <span class="o">=</span> <span class="n">biobox</span><span class="o">.</span><span class="n">Assembly</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A2</span><span class="o">.</span><span class="n">load_list</span><span class="p">([</span><span class="n">S</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">C</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="s2">&quot;C1&quot;</span><span class="p">,</span> <span class="s2">&quot;C2&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>Now, we will arrange the three loaded structures so that the bases of two cylinders are in touch with the sphere, and one cylinder is rotated by 45 degrees with respect to the other.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A2</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">cylinder_length</span><span class="o">/</span><span class="mf">2.0</span><span class="o">-</span><span class="n">sphere_radius</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;C1&quot;</span><span class="p">,</span> <span class="s2">&quot;C2&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A2</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">45.0</span><span class="p">,</span> <span class="mf">180.0</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;C2&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>As you can see, translations (and rotations) can be applied to units subsets.
In this case, we kept the sphere fixed, and only translated the cylinders, and then rotated just one of the two cylinders.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>this super-coarse grain approach was exploited to calculate the collision cross-section of curved chains of ellipsoids in <a class="reference external" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4832279">M. A. McDowell et al., Characterisation of Shigella Spa33 and Thermotoga FliM/N reveals a new model for C-ring assembly in T3SS, Molecular Microbiology, 2015</a> (Fig.3)</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>a graphical representation of typical membrane protein arrangements was obtained combining super-coarse grain models and <a class="reference external" href="http://www.ks.uiuc.edu/Research/vmd">VMD</a>-generated lipid bilayers, Fig.3 of <a class="reference external" href="http://pubs.acs.org/doi/abs/10.1021/jacs.5b00420">C. Bechara and C. V. Robinson, Different Modes of Lipid Binding to Membrane Proteins Probed by Mass Spectrometry, JACS, 2015</a></p>
</div>
</section>
<section id="density-map-cutoff-via-collision-cross-section">
<h2>density map cutoff via Collision Cross Section<a class="headerlink" href="#density-map-cutoff-via-collision-cross-section" title="Permalink to this headline">¶</a></h2>
<p>Ion Mobility (IM) experiments report on a molecule’s collision cross section (CCS).
Here we show how to relate IM data with a electron density 3D reconstruction obtained by Electron Microscopy (EM).</p>
<p>We first import a GroEL density map EMD-1457.mrc.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">biobox</span><span class="o">.</span><span class="n">Density</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span><span class="o">.</span><span class="n">import_map</span><span class="p">(</span><span class="s2">&quot;EMD-1457.mrc&quot;</span><span class="p">,</span> <span class="s2">&quot;mrc&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Depending on which threshold value one selects, the resulting isosurface will have a certain volume and CCS.
We now compute the map’s relationship between threshold, volume and CCS with 100 equally spaced threshold values.
This might take several minutes, depending on map size (by default, a scan between minimal and maximal map intensity is performed).
Obtained values will be returned in a numpy array containining as columns [threshold, volume, CCS].
This will also be stored in self.properties[‘scan’], for future usage.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tvc</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">threshold_vol_ccs</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sampling_points</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>Let’s predict the density CCS using a fitted mass-based threshold, and compare it the known CCS of 24500 A^2.
This requires providing the map’s resolution (here, 5.4 Angstrom) and the mass of GroEL (801 kDa).
The procedure interrogates the data previously stored in D.properties[‘scan’].</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ccs_mass</span><span class="p">,</span> <span class="n">fitted_mass_thresh</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">predict_ccs_from_mass</span><span class="p">(</span><span class="mf">5.4</span><span class="p">,</span> <span class="mi">801</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">error</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ccs_mass</span> <span class="o">-</span> <span class="mi">24500</span><span class="p">)</span><span class="o">/</span><span class="mi">24500</span><span class="p">)</span>
</pre></div>
</div>
<p>Error should be typically less than 5%. Values greater than 8% indicate that the protein’s conformation is likely different between EM and IM.
We can use fitted_mass_thresh to create a bead model, that can then be saved into a PDB.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span><span class="o">.</span><span class="n">place_points</span><span class="p">(</span><span class="n">fitted_mass_thresh</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span><span class="o">.</span><span class="n">write_pdb</span><span class="p">(</span><span class="s2">&quot;model_ccs_mass.pdb&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>this method is described in <a class="reference external" href="http://pubs.rsc.org/en/Content/ArticleLanding/2016/AN/C5AN01636C">M. T. Degiacomi and J. L. P. Benesch, EMnIM: software for relating ion mobility mass spectrometry and electron microscopy data, Analyst, 2016</a></p>
</div>
</section>
<section id="lipids-density-around-protein">
<h2>lipids density around protein<a class="headerlink" href="#lipids-density-around-protein" title="Permalink to this headline">¶</a></h2>
<p>One of the questions one may want to answer when running a Molecular Dynamics (MD) simulation of a protein in a membrane is:
where do lipids spend most of their time?</p>
<p>Given an MD simulation, in a preprocessing step, align all frames around the protein, and save the resulting trajectory in a multi-PDB file.
First, we identify the position of every phosphorus atom (P):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">biobox</span><span class="o">.</span><span class="n">Molecule</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">import_pdb</span><span class="p">(</span><span class="s2">&quot;trajectory.pdb&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">atomselect</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="s2">&quot;P&quot;</span><span class="p">,</span> <span class="n">get_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>We then extract the coordinate of every selected atom at any time in the simulation, ignoring the first 20 frames (equilibration).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">crds</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="mi">20</span><span class="p">:,</span> <span class="n">idx</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atoms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">crds</span><span class="p">,</span> <span class="p">(</span><span class="n">crds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">crds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
<p>We finally generate a density map of the resulting collection of points, and save it in a DX file.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">biobox</span><span class="o">.</span><span class="n">Structure</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">get_density</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span><span class="o">.</span><span class="n">write_dx</span><span class="p">(</span><span class="s2">&quot;density.dx&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>The approach described here was used in <a class="reference external" href="http://www.nature.com/articles/ncomms13993">Landreh et al., Integrating mass spectrometry with MD simulations reveals the role of lipids in Na+/H+ antiporters,  Nature Communications, 2017</a></p>
</div>
</section>
<section id="calculating-cross-linking-distance">
<h2>calculating cross-linking distance<a class="headerlink" href="#calculating-cross-linking-distance" title="Permalink to this headline">¶</a></h2>
<p>Cross-linking experiments report on the distance between the side chain of specific amino-acids.
This distance, measured by a cross-linker molecule, is however not a straight line, but a “shortest solvent accessible path”.</p>
<p>To identify in a structure which lysines may be cross-linked, we start loading it and identifying the location of all lysines’ NZ atoms:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">biobox</span><span class="o">.</span><span class="n">Molecule</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="o">.</span><span class="n">import_pdb</span><span class="p">(</span><span class="s2">&quot;protein.pdb&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">atomselect</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="s2">&quot;LYS&quot;</span><span class="p">,</span> <span class="s2">&quot;NZ&quot;</span><span class="p">,</span> <span class="n">use_resname</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">get_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>To calculate the path distance between all these atoms, we must first define which protein atoms should be used for clash detection.
Here, we select all backbone atoms as well as beta carbon ones. Furthermore, atoms buried in the protein core are also added (with densify=True).
This makes the protein core more “dense”, reducing the likelihood that a path will find its way through the protein, instead of around it.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">XL</span> <span class="o">=</span> <span class="n">biobox</span><span class="o">.</span><span class="n">Xlink</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">XL</span><span class="o">.</span><span class="n">set_clashing_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;CA&quot;</span><span class="p">,</span> <span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;O&quot;</span><span class="p">,</span> <span class="s2">&quot;CB&quot;</span><span class="p">],</span> <span class="n">densify</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>We then set up the grid used by the path detection algorithms.
Here, we use a local search, using a cubic moving grid of 18 Angstrom per side.
After this, the distance matrix path detection algorithm can be launched.
We will use a lazy Theta* method, with flexible side chains, and path smoothing as postprocessing.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">XL</span><span class="o">.</span><span class="n">setup_local_search</span><span class="p">(</span><span class="n">maxdist</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">distance_mat</span> <span class="o">=</span> <span class="n">XL</span><span class="o">.</span><span class="n">distance_matrix</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;theta&quot;</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">flexible_sidechain</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>distance_mat is the distance matrix between all lysines, sorted according to idx.
It will contain -1 for lysine’s linking atoms too far to be encompassed by the moving grid, and -2 for failed path detection (e.g. because a linking atom is buried).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>this method is presented and benchmarked in <a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S0969212617302915?via%3Dihub">M. T. Degiacomi et al., Accommodating protein dynamics in the analysis of chemical cross-links, Structure, 2017</a></p>
</div>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Examples</a><ul>
<li><a class="reference internal" href="#selecting-atoms-from-a-multi-pdb">Selecting atoms from a (multi)PDB</a></li>
<li><a class="reference internal" href="#protein-conformations-clustering">protein conformations clustering</a></li>
<li><a class="reference internal" href="#protein-polyhedral-assemblies">protein polyhedral assemblies</a></li>
<li><a class="reference internal" href="#super-coarse-grain-modelling">super coarse-grain modelling</a></li>
<li><a class="reference internal" href="#density-map-cutoff-via-collision-cross-section">density map cutoff via Collision Cross Section</a></li>
<li><a class="reference internal" href="#lipids-density-around-protein">lipids density around protein</a></li>
<li><a class="reference internal" href="#calculating-cross-linking-distance">calculating cross-linking distance</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="measures.html"
                        title="previous chapter">Measures</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/examples.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="measures.html" title="Measures"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">biobox 1.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Examples</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021, Matteo Degiacomi.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.0.2.
    </div>
  </body>
</html>