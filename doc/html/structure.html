
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Single Structures &#8212; biobox 1.0 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Assemblies" href="assembly.html" />
    <link rel="prev" title="BiobOx’s documentation" href="index.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="assembly.html" title="Assemblies"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="BiobOx’s documentation"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">biobox 1.0 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="single-structures">
<h1>Single Structures<a class="headerlink" href="#single-structures" title="Permalink to this headline">¶</a></h1>
<p>The main data structure in BiobOx is the <a class="reference internal" href="#structure.Structure" title="structure.Structure"><code class="xref py py-func docutils literal"><span class="pre">Structure</span></code></a> class, which handles collections of 3D points.
Points are stored in a MxNx3 <strong>coordinates array</strong>, where M is the number of alternative points arrangements, and N is the amount of points.</p>
<p>At any moment, one of the loaded points conformations is considered to be the active one (a.k.a. <strong>current</strong>).
Any rototranslation or measuring operation will be performed on the current structure only.
Some methods, e.g. <a class="reference internal" href="#structure.Structure.rmsd" title="structure.Structure.rmsd"><code class="xref py py-func docutils literal"><span class="pre">rmsd</span></code></a> allow comparing different conformations, independently from which is the current one.</p>
<p>The current conformation in the coordinates array can be changed by calling the <a class="reference internal" href="#structure.Structure.set_current" title="structure.Structure.set_current"><code class="xref py py-func docutils literal"><span class="pre">set_current</span></code></a> method (altering the Structure’s <strong>current</strong> attribute).
For comfort, the current conformation is accessible in the <strong>points</strong> Nx3 array, where:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">current</span><span class="p">]</span>
</pre></div>
</div>
<p>Points attributes are stored in a pandas <strong>dataframe</strong>. For instance, self.data[“radius”] contains each point’s radius.
A property of the whole point cloud can be stored in a properties dictionary (e.g. self.properties[“center”]).</p>
<p>Several <a class="reference internal" href="#structure.Structure" title="structure.Structure"><code class="xref py py-func docutils literal"><span class="pre">Structure</span></code></a> subclasses are available (<a class="reference internal" href="#molecule.Molecule" title="molecule.Molecule"><code class="xref py py-func docutils literal"><span class="pre">Molecule</span></code></a>, <a class="reference internal" href="#convex.Ellipsoid" title="convex.Ellipsoid"><code class="xref py py-func docutils literal"><span class="pre">Ellipsoid</span></code></a>, <a class="reference internal" href="#convex.Cylinder" title="convex.Cylinder"><code class="xref py py-func docutils literal"><span class="pre">Cylinder</span></code></a>, <a class="reference internal" href="#convex.Cone" title="convex.Cone"><code class="xref py py-func docutils literal"><span class="pre">Cone</span></code></a>, <a class="reference internal" href="#convex.Sphere" title="convex.Sphere"><code class="xref py py-func docutils literal"><span class="pre">Sphere</span></code></a>, <a class="reference internal" href="#convex.Prism" title="convex.Prism"><code class="xref py py-func docutils literal"><span class="pre">Prism</span></code></a>, <a class="reference internal" href="#density.Density" title="density.Density"><code class="xref py py-func docutils literal"><span class="pre">Density</span></code></a>, see below).</p>
<div class="section" id="module-structure">
<span id="structure"></span><h2>Structure<a class="headerlink" href="#module-structure" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="structure.Structure">
<em class="property">class </em><code class="descname">Structure</code><span class="sig-paren">(</span><em>p=array([]</em>, <em>shape=(2</em>, <em>0)</em>, <em>dtype=float64)</em>, <em>r=1.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure" title="Permalink to this definition">¶</a></dt>
<dd><p>A Structure consists of an ensemble of points in 3D space, and metadata associated to each of them.</p>
<p>Point coordinates and properties data structures are first initialized.
properties is a dictionary initially containing an entry for ‘center’ (center of geometry) and ‘radius’ (average radius of points).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>p</strong> – coordinates data structure as a mxnx3 numpy array (alternative conformation x atom x 3D coordinate). nx3 numpy array can be supplied, in case a single conformation is present.</li>
<li><strong>r</strong> – average radius of every point in dataset (float), or radius of every point (numpy array)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="structure.Structure.add_xyz">
<code class="descname">add_xyz</code><span class="sig-paren">(</span><em>coords</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.add_xyz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.add_xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>add a new alternative conformation to the database</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>coords</strong> – array of 3D points, or array of arrays of 3D points (in case multiple alternative coordinates must be added at the same time)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.align_axes">
<code class="descname">align_axes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.align_axes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.align_axes" title="Permalink to this definition">¶</a></dt>
<dd><p>Align structure on its principal axes.</p>
<p>First principal axis aligned along x, second along y and third along z.</p>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.apply_transformation">
<code class="descname">apply_transformation</code><span class="sig-paren">(</span><em>M</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.apply_transformation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.apply_transformation" title="Permalink to this definition">¶</a></dt>
<dd><p>apply a 3x3 transformation matrix</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>M</strong> – 3x3 transformation matrix (2D numpy array)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.center_to_origin">
<code class="descname">center_to_origin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.center_to_origin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.center_to_origin" title="Permalink to this definition">¶</a></dt>
<dd><p>move the structure so that its center of geometry is at the origin.</p>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.clear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>remove all the coordinates and empty metadata</p>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.convex_hull">
<code class="descname">convex_hull</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.convex_hull"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.convex_hull" title="Permalink to this definition">¶</a></dt>
<dd><p>compute Structure’s convex Hull using QuickHull algorithm.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Qhull available only on scipy &gt;=0.12</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><a class="reference internal" href="#structure.Structure" title="structure.Structure"><code class="xref py py-func docutils literal"><span class="pre">Structure</span></code></a> object, containing the coordinates of vertices composing the convex hull</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="structure.Structure.coordinates">
<code class="descname">coordinates</code><em class="property"> = None</em><a class="headerlink" href="#structure.Structure.coordinates" title="Permalink to this definition">¶</a></dt>
<dd><p>numpy array containing an ensemble of alternative coordinates in 3D space</p>
</dd></dl>

<dl class="attribute">
<dt id="structure.Structure.current">
<code class="descname">current</code><em class="property"> = None</em><a class="headerlink" href="#structure.Structure.current" title="Permalink to this definition">¶</a></dt>
<dd><p>index of currently selected conformation</p>
</dd></dl>

<dl class="attribute">
<dt id="structure.Structure.data">
<code class="descname">data</code><em class="property"> = None</em><a class="headerlink" href="#structure.Structure.data" title="Permalink to this definition">¶</a></dt>
<dd><p>metadata about each atom (pandas Dataframe)</p>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.delete_xyz">
<code class="descname">delete_xyz</code><span class="sig-paren">(</span><em>index</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.delete_xyz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.delete_xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>remove one conformation from the conformations database.</p>
<p>the new current conformation will be the previous one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>index</strong> – alternative coordinates set to remove</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.get_center">
<code class="descname">get_center</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.get_center"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.get_center" title="Permalink to this definition">¶</a></dt>
<dd><p>compute protein center of geometry (also assigns it to self.properties[“center”] key).</p>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.get_density">
<code class="descname">get_density</code><span class="sig-paren">(</span><em>step=1.0</em>, <em>sigma=1.0</em>, <em>kernel_half_width=5</em>, <em>buff=3</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.get_density"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.get_density" title="Permalink to this definition">¶</a></dt>
<dd><p>generate density map from points</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>step</strong> – size of cubic voxels, in Angstrom</li>
<li><strong>sigma</strong> – gaussian kernel sigma</li>
<li><strong>kernel_half_width</strong> – kernel half width, in voxels</li>
<li><strong>buff</strong> – padding to add at points cloud boundaries</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#density.Density" title="density.Density"><code class="xref py py-func docutils literal"><span class="pre">Density</span></code></a> object, containing a simulated density map</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.get_principal_axes">
<code class="descname">get_principal_axes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.get_principal_axes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.get_principal_axes" title="Permalink to this definition">¶</a></dt>
<dd><p>compute Structure’s principal axes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">3x3 numpy array, containing the 3 principal axes ranked from smallest to biggest.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.get_size">
<code class="descname">get_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.get_size"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.get_size" title="Permalink to this definition">¶</a></dt>
<dd><p>compute the dimensions of the object along x, y and z.</p>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.get_xyz">
<code class="descname">get_xyz</code><span class="sig-paren">(</span><em>indices=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.get_xyz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.get_xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>get points coordinates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>indices</strong> – indices of points to select. If none is provided, all points coordinates are returned.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">coordinates of all points indexed by the provided indices list, or all of them if no list is provided.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.pca">
<code class="descname">pca</code><span class="sig-paren">(</span><em>components</em>, <em>indices=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.pca"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.pca" title="Permalink to this definition">¶</a></dt>
<dd><p>compute Principal Components Analysis (PCA) on specific points within all the alternative coordinates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>components</strong> – eigenspace dimensions</li>
<li><strong>indices</strong> – points indices to be considered for PCA</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">numpy array of projection of each conformation into the n-dimensional eigenspace</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">sklearn PCA object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="structure.Structure.points">
<code class="descname">points</code><em class="property"> = None</em><a class="headerlink" href="#structure.Structure.points" title="Permalink to this definition">¶</a></dt>
<dd><p>pointer to currently selected conformation</p>
</dd></dl>

<dl class="attribute">
<dt id="structure.Structure.properties">
<code class="descname">properties</code><em class="property"> = None</em><a class="headerlink" href="#structure.Structure.properties" title="Permalink to this definition">¶</a></dt>
<dd><p>collection of properties. By default, ‘center’ (geometric center of the Structure) is defined</p>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.rmsd">
<code class="descname">rmsd</code><span class="sig-paren">(</span><em>i</em>, <em>j</em>, <em>points_index=[]</em>, <em>full=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.rmsd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.rmsd" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the RMSD between two structures in alternative coordinates ensemble.
uses Kabsch alignement algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>i</strong> – index of the first structure</li>
<li><strong>j</strong> – index of the second structure</li>
<li><strong>points_index</strong> – if set, only specific points will be considered for comparison</li>
<li><strong>full</strong> – if True, RMSD an rotation matrx are returned, RMSD only otherwise</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">RMSD of the two structures. If full is True, the rotation matrix is also returned</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.rmsd_distance_matrix">
<code class="descname">rmsd_distance_matrix</code><span class="sig-paren">(</span><em>points_index=[]</em>, <em>flat=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.rmsd_distance_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.rmsd_distance_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>compute distance matrix between structures (using RMSD as metric).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>points_index</strong> – if set, only specific points will be considered for comparison</li>
<li><strong>flat</strong> – if True, returns flattened distance matrix</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">RMSD distance matrix</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.rmsd_one_vs_all">
<code class="descname">rmsd_one_vs_all</code><span class="sig-paren">(</span><em>ref_index</em>, <em>points_index=[]</em>, <em>align=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.rmsd_one_vs_all"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.rmsd_one_vs_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the RMSD between all structures with respect of a reference structure.
uses Kabsch alignement algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ref_index</strong> – index of reference structure in conformations database</li>
<li><strong>points_index</strong> – if set, only specific points will be considered for comparison</li>
<li><strong>align</strong> – if set to true, all conformations will be aligned to reference (note: cannot be undone!)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">RMSD of all structures with respect of reference structure (in a numpy array)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.rmsf">
<code class="descname">rmsf</code><span class="sig-paren">(</span><em>indices=-1</em>, <em>step=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.rmsf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.rmsf" title="Permalink to this definition">¶</a></dt>
<dd><p>compute Root Mean Square Fluctuation (RMSF) of selected atoms.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>indices</strong> – indices of points for which RMSF will be calculated. If no indices list is provided, RMSF of all points will be calculated.</li>
<li><strong>step</strong> – timestep between two conformations (useful when using conformations extracted from molecular dynamics)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">numpy aray with RMSF of all provided indices, in the same order</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.rotate">
<code class="descname">rotate</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.rotate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>rotate the structure provided angles of rotation around x, y and z axes (in degrees).</p>
<p>This is a rotation with respect of the origin.
Make sure that the center of your structure is at the origin, if you don’t want to get a translation as well!
rotating an object being not centered requires to first translate the ellipsoid at the origin, rotate it, and bringing it back.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> – rotation around x axis</li>
<li><strong>y</strong> – rotation around y axis</li>
<li><strong>z</strong> – rotation around z axis</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.rotation_matrix">
<code class="descname">rotation_matrix</code><span class="sig-paren">(</span><em>axis</em>, <em>theta</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.rotation_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.rotation_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>compute matrix needed to rotate the system around an arbitrary axis (using Euler-Rodrigues formula).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>axis</strong> – 3d vector (numpy array), representing the axis around which to rotate</li>
<li><strong>theta</strong> – desired rotation angle</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">3x3 rotation matrix</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.set_current">
<code class="descname">set_current</code><span class="sig-paren">(</span><em>pos</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.set_current"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.set_current" title="Permalink to this definition">¶</a></dt>
<dd><p>select current frame (place frame pointer at desired position)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>pos</strong> – number of alternative conformation (starting from 0)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.set_xyz">
<code class="descname">set_xyz</code><span class="sig-paren">(</span><em>coords</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.set_xyz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.set_xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>set point coordinates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>coords</strong> – array of 3D points</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.translate">
<code class="descname">translate</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.translate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.translate" title="Permalink to this definition">¶</a></dt>
<dd><p>translate the whole structure by a given amount.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> – translation around x axis</li>
<li><strong>y</strong> – translation around y axis</li>
<li><strong>z</strong> – translation around z axis</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.write_pdb">
<code class="descname">write_pdb</code><span class="sig-paren">(</span><em>filename</em>, <em>index=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.write_pdb"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.write_pdb" title="Permalink to this definition">¶</a></dt>
<dd><p>write a multi PDB file where every point is a sphere. VdW radius is written into beta factor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> – name of file to output</li>
<li><strong>index</strong> – list of frame indices to write to file. By default, a multipdb with all frames will be produced.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-molecule">
<span id="molecule"></span><h2>Molecule<a class="headerlink" href="#module-molecule" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="molecule.Molecule">
<em class="property">class </em><code class="descname">Molecule</code><a class="reference internal" href="_modules/molecule.html#Molecule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">biobox.classes.structure.Structure</span></code></p>
<p>Subclass of <a class="reference internal" href="#structure.Structure" title="structure.Structure"><code class="xref py py-func docutils literal"><span class="pre">Structure</span></code></a>, allows reading, manipulating and analyzing molecular structures.</p>
<p>At instantiation, properties associated to every individual atoms are stored in a pandas Dataframe self.data.
The columns of the self.data have the following names:
atom, index, name, resname, chain, resid, beta, occupancy, atomtype, radius, charge.</p>
<p>self.knowledge contains a knowledge base about atoms and residues properties. Default values are:</p>
<ul class="simple">
<li>‘residue_mass’ property stores the average mass for most common aminoacids (values from Expasy website)</li>
<li>‘atom_vdw’ vdw radius of common atoms</li>
<li>‘atom_mass’ mass of common atoms</li>
</ul>
<p>The knowledge base can be edited. For instance, to add information about residue “TST” mass in molecule M type: M.knowledge[‘mass_residue’][“TST”]=142.42</p>
<dl class="method">
<dt id="molecule.Molecule.apply_biomatrix">
<code class="descname">apply_biomatrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.apply_biomatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.apply_biomatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>if biomatrix information is provided, generate a new molecule with all symmetry operators applied.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">new Molecule containing several copies of the current Molecule, arranged according to BIOMT statements contained in pdb, or -1 if no transformation matrix is provided</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.apply_symmetry">
<code class="descname">apply_symmetry</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.apply_symmetry"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.apply_symmetry" title="Permalink to this definition">¶</a></dt>
<dd><p>if symmetry information is provided, generate a new molecule with all symmetry operators applied.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">new Molecule containing several copies of the current Molecule, arranged according to SMTRY statements contained in pdb, or -1 if no transformation matrix is provided</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.assign_atomtype">
<code class="descname">assign_atomtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.assign_atomtype"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.assign_atomtype" title="Permalink to this definition">¶</a></dt>
<dd><p>guess atomtype from atom names</p>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.atomignore">
<code class="descname">atomignore</code><span class="sig-paren">(</span><em>chain</em>, <em>res</em>, <em>atom</em>, <em>get_index=False</em>, <em>use_resname=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.atomignore"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.atomignore" title="Permalink to this definition">¶</a></dt>
<dd><p>Select specific atoms that do not match a specific query (chain, residue ID and atom name).
Useful to remove from a molecule atoms unwanted for further analysis, alternative conformations, etc…</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>chain</strong> – chain name (accepts * as wildcard). Can also be a list or numpy array of strings.</li>
<li><strong>res</strong> – residue ID (accepts * as wildcard). Can also be a list or numpy array of of int.</li>
<li><strong>atom</strong> – atom name (accepts * as wildcard). Can also be a list or numpy array of strings.</li>
<li><strong>get_index</strong> – if set to True, returns the indices of atoms in self.points array (and self.data)</li>
<li><strong>use_resname</strong> – if set to True, consider information in “res” variable as resnames, and not resids</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">coordinates of the selected points not matching the query, if get_index is set to true, their indices in self.points array.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.atomselect">
<code class="descname">atomselect</code><span class="sig-paren">(</span><em>chain</em>, <em>res</em>, <em>atom</em>, <em>get_index=False</em>, <em>use_resname=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.atomselect"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.atomselect" title="Permalink to this definition">¶</a></dt>
<dd><p>Select specific atoms in the protein providing chain, residue ID and atom name.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>chain</strong> – selection of a specific chain name (accepts * as wildcard). Can also be a list or numpy array of strings.</li>
<li><strong>res</strong> – residue ID of desired atoms (accepts * as wildcard). Can also be a list or numpy array of of int.</li>
<li><strong>atom</strong> – name of desired atom (accepts * as wildcard). Can also be a list or numpy array of strings.</li>
<li><strong>get_index</strong> – if set to True, returns the indices of selected atoms in self.points array (and self.data)</li>
<li><strong>use_resname</strong> – if set to True, consider information in “res” variable as resnames, and not resids</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">coordinates of the selected points and, if get_index is set to true, their indices in self.points array.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.beta_factor_from_rmsf">
<code class="descname">beta_factor_from_rmsf</code><span class="sig-paren">(</span><em>indices=-1</em>, <em>step=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.beta_factor_from_rmsf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.beta_factor_from_rmsf" title="Permalink to this definition">¶</a></dt>
<dd><p>estimate atoms beta factor on the base of their RMSF.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>indices</strong> – indices of atoms of interest. If not set all atoms will be considered.</li>
<li><strong>step</strong> – timestep between two conformations (useful when using conformations extracted from molecular dynamics)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.get_atoms_ccs">
<code class="descname">get_atoms_ccs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.get_atoms_ccs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.get_atoms_ccs" title="Permalink to this definition">¶</a></dt>
<dd><p>return array with atomic CCS radii of every atom in molecule</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">CCS in Angstrom^2</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.get_couples">
<code class="descname">get_couples</code><span class="sig-paren">(</span><em>idx</em>, <em>cutoff</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.get_couples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.get_couples" title="Permalink to this definition">¶</a></dt>
<dd><p>given a list of indices, compute the all-vs-all distance and return only couples below a given cutoff distance</p>
<p>useful for the detection of disulfide bridges or linkable sites via cross-linking (approximation, supposing euclidean distances)’</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>idx</strong> – indices of atoms to check.</li>
<li><strong>cutoff</strong> – minimal distance to consider a couple as linkable.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">nx3 numpy array containing, for every valid connection, id of first atom, id of second atom and distance between the two.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.get_data">
<code class="descname">get_data</code><span class="sig-paren">(</span><em>indices=[]</em>, <em>columns=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.get_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.get_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Return information about atoms of interest (i.e., slice the data DataFrame)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>indices</strong> – list of indices, if not provided all atom data is returned</li>
<li><strong>columns</strong> – list of columns (e.g. [“resname”, “resid”, “chain”]), if not provided all columns are returned</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">numpy array containing a slice of molecule’s data</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.get_dipole_density">
<code class="descname">get_dipole_density</code><span class="sig-paren">(</span><em>dipole_map</em>, <em>orig</em>, <em>min_val</em>, <em>V</em>, <em>outname</em>, <em>vox_in_window=3.0</em>, <em>eqn='gauss'</em>, <em>T=310.15</em>, <em>P=101000.0</em>, <em>epsilonE=54.0</em>, <em>resolution=1.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.get_dipole_density"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.get_dipole_density" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to generate an electron density map based on a voxel grid of dipole vectors</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dipole_map</strong> – The dipole map input. Can be generated with get_dipole_map above</li>
<li><strong>orig</strong> – Origin points for voxel grid</li>
<li><strong>min_val</strong> – Minimum coordinates of edge points for the voxel grid (i.e. a single x, y, z point defining the start point of the grid to match with the multipdb)</li>
<li><strong>V</strong> – Volume of a voxel (can be found by resolution**3, but left blank in case later version institute a sphere)</li>
<li><strong>outname</strong> – Name of electron density map file produced</li>
<li><strong>vox_in_window</strong> – Amount of surrounding space to contribute to local dipole. vox_in_window * resolution gives window size (in Ang.)</li>
<li><strong>eqn</strong> – Equation mode to model the electron density</li>
<li><strong>T</strong> – Temperature of MD</li>
<li><strong>P</strong> – Pressure of MD</li>
<li><strong>epsilonE</strong> – Continuum dielectric surrounding the protein</li>
<li><strong>resolution</strong> – Desired resolution of voxel</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.get_dipole_map">
<code class="descname">get_dipole_map</code><span class="sig-paren">(</span><em>orig</em>, <em>pqr</em>, <em>time_start=0</em>, <em>time_end=2</em>, <em>resolution=1.0</em>, <em>vox_in_window=3.0</em>, <em>write_dipole_map=True</em>, <em>fname='dipole_map.tcl'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.get_dipole_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.get_dipole_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Method for generating dipole maps to be used for electron density map generation. Also prints a dipole map as a result (and if desired). It calls a cython code in lib.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>orig</strong> – Origin points for voxel grid</li>
<li><strong>pqr</strong> – PQR file for self. Can be generated by calling pdb2pqr above</li>
<li><strong>time_start</strong> – First frame to parse in multipdb</li>
<li><strong>time_end</strong> – Last frame to parse in multipdb</li>
<li><strong>resolution</strong> – Desired resolution of voxel</li>
<li><strong>vox_in_window</strong> – Amount of surrounding space to contribute to local dipole. vox_in_window * resolution gives window size (in Ang.)</li>
<li><strong>write_dipole_map</strong> – Write a dipole map in TCL format to be read in via VMD.</li>
<li><strong>fname</strong> – Name of desired dipole map to be written</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.get_electrostatics">
<code class="descname">get_electrostatics</code><span class="sig-paren">(</span><em>step=1.0</em>, <em>buff=3</em>, <em>threshold=0.01</em>, <em>vdw_kernel_half_width=5</em>, <em>elect_kernel_half_width=12</em>, <em>chain='*'</em>, <em>clear_mass=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.get_electrostatics"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.get_electrostatics" title="Permalink to this definition">¶</a></dt>
<dd><p>generate electrostatics map from points</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>step</strong> – size of cubic voxels, in Angstrom</li>
<li><strong>buff</strong> – padding to add at points cloud boundaries</li>
<li><strong>threshold</strong> – Threshold used for removing mass occupied space from the electron density map</li>
<li><strong>vdw_kernel_half_width</strong> – kernel half width, in voxels</li>
<li><strong>elect_kernel_half_width</strong> – kernel half width, in voxels</li>
<li><strong>chain</strong> – select chain to use, default all chains</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">positive <a class="reference internal" href="#density.Density" title="density.Density"><code class="xref py py-func docutils literal"><span class="pre">Density</span></code></a> object</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">negative <a class="reference internal" href="#density.Density" title="density.Density"><code class="xref py py-func docutils literal"><span class="pre">Density</span></code></a> object</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">mass density object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.get_mass_by_atom">
<code class="descname">get_mass_by_atom</code><span class="sig-paren">(</span><em>skip_resname=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.get_mass_by_atom"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.get_mass_by_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>compute protein mass using atoms in pdb</p>
<p>sum the mass of all atoms (using a knowledge base of atom masses in Dalton)
The knowledge base can be expanded or edited by adding or editing entries to the molecule’s mass dictionary, e.g. to add the atom “PI” mass in molecule M type: M.knowledge[‘atom_mass’][“PI”]=3.141592</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>skip_resname</strong> – list of resnames to skip. Useful to exclude ions water or other ligands from the calculation.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">mass of molecule in Dalton</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.get_mass_by_residue">
<code class="descname">get_mass_by_residue</code><span class="sig-paren">(</span><em>skip_resname=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.get_mass_by_residue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.get_mass_by_residue" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute protein mass using residues (i.e. account also for atoms not present in the structure)</p>
<p>Sum the average mass all every residue (using a knowledge base of atom masses in Dalton)
The knowledge base can be expanded or edited by adding entries to the molecule’s mass dictionary, e.g. to add the residue “TST” mass in molecule M type: M.knowledge[‘mass_residue’][“TST”]=142.42</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>skip_resname</strong> – list of resnames to skip. Useful to exclude ions water or other ligands from the calculation.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">mass of molecule in Dalton</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.get_pdb_data">
<code class="descname">get_pdb_data</code><span class="sig-paren">(</span><em>index=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.get_pdb_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.get_pdb_data" title="Permalink to this definition">¶</a></dt>
<dd><p>aggregate data and point coordinates, and return in a unique data structure</p>
<p>Returned data is a list containing strings for points data and floats for point coordinates
in the same order as a pdb file, i.e.
ATOM/HETATM, index, name, resname, chain name, residue ID, x, y, z, occupancy, beta factor, atomtype.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list aggregated data and coordinates for every point, as string.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.get_secondary_structure">
<code class="descname">get_secondary_structure</code><span class="sig-paren">(</span><em>dssp_path=''</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.get_secondary_structure"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.get_secondary_structure" title="Permalink to this definition">¶</a></dt>
<dd><p>compute the protein’s secondary structure, calling DSSP
:param dssp_path: DSSP executable (path and filename). If not provided, the default behaviour is to seek for this information in the environment variable DSSPPATH
:returns: numpy array of characters, with one-letter-coded secondary sctructure according to DSSP.</p>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.get_subset">
<code class="descname">get_subset</code><span class="sig-paren">(</span><em>idxs</em>, <em>conformations=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.get_subset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.get_subset" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <a class="reference internal" href="#molecule.Molecule" title="molecule.Molecule"><code class="xref py py-func docutils literal"><span class="pre">Molecule</span></code></a> object containing only the selected atoms and frames</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ixds</strong> – atoms to extract</li>
<li><strong>conformations</strong> – frames to extract (by default, all)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#molecule.Molecule" title="molecule.Molecule"><code class="xref py py-func docutils literal"><span class="pre">Molecule</span></code></a> object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.get_vdw_density">
<code class="descname">get_vdw_density</code><span class="sig-paren">(</span><em>buff=3</em>, <em>step=0.5</em>, <em>kernel_half_width=10</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.get_vdw_density"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.get_vdw_density" title="Permalink to this definition">¶</a></dt>
<dd><p>generate density map from points based on the van der Waals readius of the atoms</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>buff</strong> – Buffer used to create the boundaries of the density map</li>
<li><strong>step</strong> – Stepsize for creating the density object</li>
<li><strong>kernel_half_width</strong> – Kernel half width of the gaussian kernel, will be scaled by atom specific sigma</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#density.Density" title="density.Density"><code class="xref py py-func docutils literal"><span class="pre">Density</span></code></a> object, containing a density map</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.guess_chain_split">
<code class="descname">guess_chain_split</code><span class="sig-paren">(</span><em>distance=3</em>, <em>use_backbone=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.guess_chain_split"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.guess_chain_split" title="Permalink to this definition">¶</a></dt>
<dd><p>reassign chain name, using distance cutoff (cannot be undone).
If two consecutive atoms are beyond a cutoff, a new chain is assigned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>distance</strong> – distance cutoff distanceR: no atomtype found!</li>
<li><strong>use_backbone</strong> – if True, splitting will be performed considering backbone atoms (N and C), all atoms in a sequence otherwise</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.import_gro">
<code class="descname">import_gro</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.import_gro"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.import_gro" title="Permalink to this definition">¶</a></dt>
<dd><p>read a gro possibly containing multiple structures.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> – name of .gro file to import</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.import_pdb">
<code class="descname">import_pdb</code><span class="sig-paren">(</span><em>pdb</em>, <em>include_hetatm=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.import_pdb"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.import_pdb" title="Permalink to this definition">¶</a></dt>
<dd><p>read a pdb (possibly containing containing multiple models).</p>
<p>Models are split according to ENDMDL and END statement.
All alternative coordinates are expected to have the same atoms.
After loading, the first model (M.current_model=0) will be set as active.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pdb</strong> – PDB filename</li>
<li><strong>include_hetatm</strong> – if True, HETATM will be included (they get skipped if False)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.import_pqr">
<code class="descname">import_pqr</code><span class="sig-paren">(</span><em>pqr</em>, <em>include_hetatm=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.import_pqr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.import_pqr" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a pqr (possibly containing containing multiple models).</p>
<p>models are split according to ENDMDL and END statement.
All alternative coordinates are expected to have the same atoms.
After loading, the first model (M.current_model=0) will be set as active.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pqr</strong> – PQR filename</li>
<li><strong>include_hetatm</strong> – if True, HETATM will be included (they get skipped if False)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.know">
<code class="descname">know</code><span class="sig-paren">(</span><em>prop</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.know"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.know" title="Permalink to this definition">¶</a></dt>
<dd><p>return information from knowledge base</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>prop</strong> – desired property to extract from knowledge base</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">value associated to requested property, or nan if failed</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.match_residue">
<code class="descname">match_residue</code><span class="sig-paren">(</span><em>M2</em>, <em>sec=5</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.match_residue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.match_residue" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares two bb.Molecule() peptide strands and returns the resids within both peptides when the two are homogenous
beyond a certain secondary structure threashold. The default is 5 amino acids (given by sec) in a row must be identical</p>
<p>Useful when aligning PDB structures that have been crystallised separately - so one may be missing the odd residue
or have a few extra at the end.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>M2</strong> – The second bb.Molecule() to compare with</li>
<li><strong>sec</strong> – Number of consecutive amino acids in a row that must match before resid’s are recorded</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.pdb2pqr">
<code class="descname">pdb2pqr</code><span class="sig-paren">(</span><em>ff=''</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.pdb2pqr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.pdb2pqr" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses data from the pdb input into a pqr format. This uses the panda dataframe with the information
regarding atom indexes, types etc. in the self.data files.
It outputs a panda dataframe with the pqr equivilent information. It requires a datafile forcefield input.
The default is the amber14sb forcefield file held within the classes/ folder.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>ff</strong> – name of forcefield text file input that needs to be read to read charges / vdw radii.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.query">
<code class="descname">query</code><span class="sig-paren">(</span><em>query_text</em>, <em>get_index=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.query"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.query" title="Permalink to this definition">¶</a></dt>
<dd><p>Select specific atoms in a multimer un the basis of a text query.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>query_text</strong> – string selecting atoms of interest. Uses the pandas query syntax, can access all columns in the dataframe self.data.</li>
<li><strong>get_index</strong> – if set to True, returns the indices of selected atoms in self.points array (and self.data)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">coordinates of the selected points (in a unique array) and, if get_index is set to true, a list of their indices in subunits’ self.points array.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.rmsf_from_beta_factor">
<code class="descname">rmsf_from_beta_factor</code><span class="sig-paren">(</span><em>indices=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.rmsf_from_beta_factor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.rmsf_from_beta_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate RMSF from atoms beta factors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>indices</strong> – indices of atoms of interest. If not set all atoms will be considered.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.s2">
<code class="descname">s2</code><span class="sig-paren">(</span><em>atomname1='N'</em>, <em>atomname2='H'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.s2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.s2" title="Permalink to this definition">¶</a></dt>
<dd><p>compute s2, given two atoms defining the vector of interest.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>atomname1</strong> – name of the first atom</li>
<li><strong>atomname2</strong> – name of the second atom</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">data numpy array containing information about residues for which measuring has been performed (i.e.[chain, resid])</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">s2 s2 of residues for which both provided input atoms have been found</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.same_residue">
<code class="descname">same_residue</code><span class="sig-paren">(</span><em>index</em>, <em>get_index=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.same_residue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.same_residue" title="Permalink to this definition">¶</a></dt>
<dd><p>Select atoms having the same residue and chain as a given atom (or list of atoms)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>indices</strong> (<em>index</em>) – of atoms of choice (integer of list of integers)</li>
<li><strong>get_index</strong> – if set to True, returns the indices of selected atoms in self.points array (and self.data)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">coordinates of the selected points and, if get_index is set to true, their indices in self.points array.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.same_residue_unique">
<code class="descname">same_residue_unique</code><span class="sig-paren">(</span><em>index</em>, <em>get_index=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.same_residue_unique"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.same_residue_unique" title="Permalink to this definition">¶</a></dt>
<dd><p>Select atoms having the same residue and chain as a given atom (or list of atoms)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>index</strong> – indices of atoms of choice (integer of list of integers)</li>
<li><strong>get_index</strong> – if set to True, returns the indices of selected atoms in self.points array (and self.data)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">coordinates of the selected points and, if get_index is set to true, their indices in self.points array.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.set_data">
<code class="descname">set_data</code><span class="sig-paren">(</span><em>value</em>, <em>indices=[]</em>, <em>columns=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.set_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Return information about atoms of interest (i.e., slice the data DataFrame)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>indices</strong> – list of indices, if not provided all atom data is returned</li>
<li><strong>columns</strong> – list of columns (e.g. [“resname”, “resid”, “chain”]), if not provided all columns are returned</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">numpy array containing a slice of molecule’s data</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.write_gro">
<code class="descname">write_gro</code><span class="sig-paren">(</span><em>outname</em>, <em>conformations=[]</em>, <em>index=''</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.write_gro"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.write_gro" title="Permalink to this definition">¶</a></dt>
<dd><p>write structure(s) in .gro format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>outname</strong> – name of .gro file to be generated.</li>
<li><strong>index</strong> – indices of atoms to write to file. If empty, all atoms are returned. Index values obtaineable with a call like: index=molecule.atomselect(“A”, [1, 2, 3], “CA”, True)[1]</li>
<li><strong>conformations</strong> – list of conformation indices to write to file. By default, all conformations will be returned.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.write_pdb">
<code class="descname">write_pdb</code><span class="sig-paren">(</span><em>outname</em>, <em>conformations=[]</em>, <em>index=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.write_pdb"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.write_pdb" title="Permalink to this definition">¶</a></dt>
<dd><p>overload superclass method for writing (multi)pdb.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>outname</strong> – name of pdb file to be generated.</li>
<li><strong>index</strong> – indices of atoms to write to file. If empty, all atoms are returned. Index values obtaineable with a call like: index=molecule.atomselect(“A”, [1, 2, 3], “CA”, True)[1]</li>
<li><strong>conformations</strong> – list of conformation indices to write to file. By default, a multipdb with all conformations will be produced.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.write_pqr">
<code class="descname">write_pqr</code><span class="sig-paren">(</span><em>outname</em>, <em>conformations=[]</em>, <em>index=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.write_pqr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.write_pqr" title="Permalink to this definition">¶</a></dt>
<dd><p>overload superclass method for writing (multi)pqr.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>outname</strong> – name of pqr file to be generated.</li>
<li><strong>index</strong> – indices of atoms to write to file. If empty, all atoms are returned. Index values obtaineable with a call like: index=molecule.atomselect(“A”, [1, 2, 3], “CA”, True)[1]</li>
<li><strong>conformations</strong> – list of conformation indices to write to file. By default, a multipdb with all conformations will be produced.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="convex-point-clouds">
<h2>Convex Point Clouds<a class="headerlink" href="#convex-point-clouds" title="Permalink to this headline">¶</a></h2>
<p>The following classes allow generating clouds of points arranged according to specific (convex) geometries.
All these classes are subclass of <a class="reference internal" href="#structure.Structure" title="structure.Structure"><code class="xref py py-func docutils literal"><span class="pre">Structure</span></code></a>.</p>
<span class="target" id="module-convex"></span><dl class="class">
<dt id="convex.Cone">
<em class="property">class </em><code class="descname">Cone</code><span class="sig-paren">(</span><em>r</em>, <em>h</em>, <em>skew=0</em>, <em>radius=1.1</em>, <em>pts_density_r=0.09817477042468103</em>, <em>pts_density_h=0.2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Cone"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Cone" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">biobox.classes.structure.Structure</span></code></p>
<p>Create an ensemble of points arranged as a cone.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>r</strong> – radius</li>
<li><strong>h</strong> – height</li>
<li><strong>skew</strong> – skewing with respect of vertical axis</li>
<li><strong>radius</strong> – size of the individual points composing it</li>
<li><strong>pts_density_r</strong> – density of points along the rotation axis (using parametric function for cylinder)</li>
<li><strong>pts_density_h</strong> – density of points along height (using parametric function for cylinder)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="convex.Cone.ccs">
<code class="descname">ccs</code><span class="sig-paren">(</span><em>gas=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Cone.ccs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Cone.ccs" title="Permalink to this definition">¶</a></dt>
<dd><p>compute cone CCS (use analytical solution using surface and gas effect)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">CCS in A^2</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="convex.Cone.get_surface">
<code class="descname">get_surface</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Cone.get_surface"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Cone.get_surface" title="Permalink to this definition">¶</a></dt>
<dd><p>compute cone surface.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">surface in A^2</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="convex.Cone.get_volume">
<code class="descname">get_volume</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Cone.get_volume"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Cone.get_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute cone volume.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">volume in A^3</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="convex.Cylinder">
<em class="property">class </em><code class="descname">Cylinder</code><span class="sig-paren">(</span><em>r</em>, <em>h</em>, <em>squeeze=1.0</em>, <em>skew=0.0</em>, <em>radius=1.1</em>, <em>pts_density_u=0.09817477042468103</em>, <em>pts_density_h=0.2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Cylinder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Cylinder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">biobox.classes.structure.Structure</span></code></p>
<p>Create an ensemble of points arranged as an elliptical cylinder.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>r</strong> – radius</li>
<li><strong>h</strong> – height</li>
<li><strong>squeeze</strong> – create an elliptical base, having axes equal to r and squeeze*r</li>
<li><strong>skew</strong> – skewing with respect of vertical axis</li>
<li><strong>radius</strong> – size of the individual points composing it</li>
<li><strong>density</strong> (<em>pts_density_h</em>) – of points along the u angle (using parametric function for cylinder)</li>
<li><strong>density</strong> – of points along the v angle (using parametric function for cylinder)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="convex.Cylinder.ccs">
<code class="descname">ccs</code><span class="sig-paren">(</span><em>gas=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Cylinder.ccs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Cylinder.ccs" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute cylinder CCS.</p>
<p>Uses Ramanujan approximation for base perimeter. Good, but not perfect for very elliptical cylinders!</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">CCS in A^2</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="convex.Cylinder.get_surface">
<code class="descname">get_surface</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Cylinder.get_surface"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Cylinder.get_surface" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute cylinder surface.</p>
<p>Uses Ramanujan approximation for base perimeter. Good, but not perfect for very elliptical cylinders!</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">surface in A^2</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="convex.Cylinder.get_volume">
<code class="descname">get_volume</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Cylinder.get_volume"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Cylinder.get_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute cylinder volume.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">volume in A^3</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="convex.Ellipsoid">
<em class="property">class </em><code class="descname">Ellipsoid</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>c</em>, <em>radius=1.9</em>, <em>pts_density_u=0.08726646259971647</em>, <em>pts_density_v=0.08726646259971647</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Ellipsoid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Ellipsoid" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">biobox.classes.structure.Structure</span></code></p>
<p>Create an ensemble of points arranged as an ellipsoid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> – x radius of the ellipsoid</li>
<li><strong>b</strong> – y radius of the ellipsoid</li>
<li><strong>c</strong> – z radius of the ellipsoid</li>
<li><strong>radius</strong> – size of the individual points composing it</li>
<li><strong>pts_density_u</strong> – This parameter defines the density of points along the u angle (using parametric function for ellipsoid)</li>
<li><strong>pts_density_v</strong> – This parameter defines the density of points along the v angle (using parametric function for ellipsoid)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="convex.Ellipsoid.ccs">
<code class="descname">ccs</code><span class="sig-paren">(</span><em>gas=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Ellipsoid.ccs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Ellipsoid.ccs" title="Permalink to this definition">¶</a></dt>
<dd><p>compute ellipsoid CCS.</p>
<p>Uses analytical approximation to surface area.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">surface in A^2</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="convex.Ellipsoid.check_inclusion">
<code class="descname">check_inclusion</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Ellipsoid.check_inclusion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Ellipsoid.check_inclusion" title="Permalink to this definition">¶</a></dt>
<dd><p>count how many points in the array p are included in the ellipsoid.</p>
<p>overloading of superclass function, which is slower (here we can use the ellipsoid functional form to speed up things)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>p</strong> – list of points (numpy array)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">quantity of points located inside the ellipsoid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="convex.Ellipsoid.get_sphericity">
<code class="descname">get_sphericity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Ellipsoid.get_sphericity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Ellipsoid.get_sphericity" title="Permalink to this definition">¶</a></dt>
<dd><p>compute ellipsoid sphericity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">ellipsoid sphericity</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="convex.Ellipsoid.get_surface">
<code class="descname">get_surface</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Ellipsoid.get_surface"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Ellipsoid.get_surface" title="Permalink to this definition">¶</a></dt>
<dd><p>compute ellipsoid surface.</p>
<p>Note: using analytical value, uses analytical approximation to surface area</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">surface in A^2</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="convex.Ellipsoid.get_volume">
<code class="descname">get_volume</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Ellipsoid.get_volume"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Ellipsoid.get_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>compute ellipsoid volume.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">volume in A^3</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="convex.Prism">
<em class="property">class </em><code class="descname">Prism</code><span class="sig-paren">(</span><em>r</em>, <em>h</em>, <em>n</em>, <em>skew=0.0</em>, <em>radius=1.1</em>, <em>pts_density_u=0.09817477042468103</em>, <em>pts_density_h=0.2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Prism"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Prism" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">biobox.classes.structure.Structure</span></code></p>
<p>Create an ensemble of points arranged as a prism (polygonal bottom and top, rectangular sides).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>r</strong> – distance of sides from center of symmetry</li>
<li><strong>h</strong> – height</li>
<li><strong>n</strong> – number of side faces</li>
<li><strong>skew</strong> – skewing with respect of vertical axis</li>
<li><strong>radius</strong> – size of the individual points composing it</li>
<li><strong>pts_density_u</strong> – density of points along the r axis (polar coordinates)</li>
<li><strong>pts_density_h</strong> – the density of points along the vertical axis</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="convex.Prism.ccs">
<code class="descname">ccs</code><span class="sig-paren">(</span><em>gas=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Prism.ccs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Prism.ccs" title="Permalink to this definition">¶</a></dt>
<dd><p>compute prism CCS.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">CCS in A^2</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="convex.Prism.get_surface">
<code class="descname">get_surface</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Prism.get_surface"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Prism.get_surface" title="Permalink to this definition">¶</a></dt>
<dd><p>compute prism surface.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">surface in A^2</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="convex.Prism.get_volume">
<code class="descname">get_volume</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Prism.get_volume"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Prism.get_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>compute prism volume.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">volume in A^3</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="convex.Sphere">
<em class="property">class </em><code class="descname">Sphere</code><span class="sig-paren">(</span><em>r</em>, <em>radius=1.9</em>, <em>n_sphere_point=960</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Sphere"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">biobox.classes.structure.Structure</span></code></p>
<p>Create an ensemble of points arranged as a sphere.</p>
<p>using golden spiral to approximate an even distribution</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>r</strong> – radius of the ellipsoid</li>
<li><strong>radius</strong> – size of the individual points composing it</li>
<li><strong>n_sphere_point</strong> – This parameter defines the amount of points in the sphere</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="convex.Sphere.ccs">
<code class="descname">ccs</code><span class="sig-paren">(</span><em>gas=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Sphere.ccs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Sphere.ccs" title="Permalink to this definition">¶</a></dt>
<dd><p>compute spheroid CCS.</p>
<p>Uses analytical approximation to surface area.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">surface in A^2</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="convex.Sphere.check_inclusion">
<code class="descname">check_inclusion</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Sphere.check_inclusion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Sphere.check_inclusion" title="Permalink to this definition">¶</a></dt>
<dd><p>count how many points in the array p are included in the sphere.</p>
<p>overloading of superclass function, which is slower (here we can use the ellipsoid functional form to speed up things)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>p</strong> – list of points (numpy array)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">quantity of points located inside the sphere</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="convex.Sphere.get_sphericity">
<code class="descname">get_sphericity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Sphere.get_sphericity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Sphere.get_sphericity" title="Permalink to this definition">¶</a></dt>
<dd><p>compute sphericity (makes sense only for squeezed spheres, obviously..)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">shape sphericity</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="convex.Sphere.get_surface">
<code class="descname">get_surface</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Sphere.get_surface"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Sphere.get_surface" title="Permalink to this definition">¶</a></dt>
<dd><p>compute sphere surface.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">surface in A^2</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="convex.Sphere.get_volume">
<code class="descname">get_volume</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Sphere.get_volume"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Sphere.get_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>compute ellipsoid volume.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">volume in A^3</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="convex.Sphere.squeeze">
<code class="descname">squeeze</code><span class="sig-paren">(</span><em>deformation</em>, <em>preserve_volume=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Sphere.squeeze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Sphere.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>squeeze sphere according to deformation coefficient(s)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>deformation</strong> – deformation coefficient. Can be a float (deformation of one axis), or a list of 2 or 3 floats.</li>
<li><strong>preserve_volume</strong> – If true and deformation is either a float or a list of 2 floats, correct remaining axes to preserve volume.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-density">
<span id="density"></span><h2>Density<a class="headerlink" href="#module-density" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="density.Density">
<em class="property">class </em><code class="descname">Density</code><a class="reference internal" href="_modules/density.html#Density"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#density.Density" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">biobox.classes.structure.Structure</span></code></p>
<p>Subclass of <a class="reference internal" href="#structure.Structure" title="structure.Structure"><code class="xref py py-func docutils literal"><span class="pre">Structure</span></code></a>, allows importing density map, and transform them in a PDB file containing a collection of spheres placed on the map’s high density regions.</p>
<p>A density map is fully described by the following attributes, stored in the self.properties dictionary:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>density</strong> – density map</li>
<li><strong>delta</strong> – scaling factor for voxels (default is [1, 1, 1] Angstrom)</li>
<li><strong>size</strong> – dimensions in voxels</li>
<li><strong>origin</strong> – bottom-left-front corner of the cube</li>
<li><strong>radius</strong> – radius of points composing the density map</li>
<li><strong>format</strong> – format name (only dx supported at the moment)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="density.Density.best_threshold">
<code class="descname">best_threshold</code><span class="sig-paren">(</span><em>mass</em>, <em>density=0.782878356</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/density.html#Density.best_threshold"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#density.Density.best_threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>If mass and density of object are known, try to filter the map so that the mass is best matched.</p>
<p>search for best threshold using bissection method.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">in proteins, an average value of 1.3 g/cm^3 (0.782878356 Da/A^3) can be assumed. Alternatively, the relation density=1.410+0.145*exp(-mass(kDa)/13) can be used.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">1 Da/A^3=1.660538946 g/cm^3</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">1 g/cm^3=0.602214120 Da/A^3</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mass</strong> – target mass in Da</li>
<li><strong>density</strong> – target density in Da/A^3</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">array reporting tested values and error on mass ([sigma, model_mass-target_mass])</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="density.Density.blur">
<code class="descname">blur</code><span class="sig-paren">(</span><em>dimension=5</em>, <em>sigma=0.5</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/density.html#Density.blur"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#density.Density.blur" title="Permalink to this definition">¶</a></dt>
<dd><p>blur density applying a cubic gaussian kernel of given kernel dimension (cubic grid size).</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">cannot be undone</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dimension</strong> – size of the kernel grid.</li>
<li><strong>sigma</strong> – standard deviation of gaussian kernel.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="density.Density.export_as_pdb">
<code class="descname">export_as_pdb</code><span class="sig-paren">(</span><em>outname</em>, <em>step</em>, <em>threshold=0.1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/density.html#Density.export_as_pdb"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#density.Density.export_as_pdb" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a pdb file with points where the density exceeds a threshold</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>outname</strong> – output file name</li>
<li><strong>step</strong> – stepsize used to generate the density map</li>
<li><strong>threshold</strong> – density to be exceeded to generate a point in pdb</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="density.Density.find_data_from_ccs">
<code class="descname">find_data_from_ccs</code><span class="sig-paren">(</span><em>ccs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/density.html#Density.find_data_from_ccs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#density.Density.find_data_from_ccs" title="Permalink to this definition">¶</a></dt>
<dd><p>map experimental data to given ccs</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>ccs</strong> – target CCS (in A^2)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="density.Density.find_data_from_sigma">
<code class="descname">find_data_from_sigma</code><span class="sig-paren">(</span><em>sigma</em>, <em>exact=True</em>, <em>append=False</em>, <em>noise_filter=0.01</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/density.html#Density.find_data_from_sigma"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#density.Density.find_data_from_sigma" title="Permalink to this definition">¶</a></dt>
<dd><p>map experimental data to given threshold</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sigma</strong> – density threshold</li>
<li><strong>noise_filter</strong> – launch DBSCAN clustering algorithm to detect connected regions in density map. Regions representing less than noise_filter of the total will be removed. This is a ratio, value should be between 0 and 1.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="density.Density.find_data_from_volume">
<code class="descname">find_data_from_volume</code><span class="sig-paren">(</span><em>vol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/density.html#Density.find_data_from_volume"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#density.Density.find_data_from_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>map experimental data to given volume</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>vol</strong> – volume</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="density.Density.get_oversampled_points">
<code class="descname">get_oversampled_points</code><span class="sig-paren">(</span><em>sigma=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/density.html#Density.get_oversampled_points"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#density.Density.get_oversampled_points" title="Permalink to this definition">¶</a></dt>
<dd><p>return points obtained by oversampling the map (doule points on every axis)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sigma</strong> – place points only on voxels having intensity greater than threshold</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">points 3D points placed on voxels having value higher than threshold</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">radius radius of produced points</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="density.Density.get_sigma_from_thresh">
<code class="descname">get_sigma_from_thresh</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/density.html#Density.get_sigma_from_thresh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#density.Density.get_sigma_from_thresh" title="Permalink to this definition">¶</a></dt>
<dd><p>convert cutoff value from actual threshold to sigma multiple</p>
<p>:param threshold value
:returns sigma multiple</p>
</dd></dl>

<dl class="method">
<dt id="density.Density.get_thresh_from_sigma">
<code class="descname">get_thresh_from_sigma</code><span class="sig-paren">(</span><em>val</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/density.html#Density.get_thresh_from_sigma"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#density.Density.get_thresh_from_sigma" title="Permalink to this definition">¶</a></dt>
<dd><p>convert cutoff value from sigma multiples into actual threshold</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>val</strong> – sigma scaling</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">cutoff</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="density.Density.get_volume">
<code class="descname">get_volume</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/density.html#Density.get_volume"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#density.Density.get_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>compute density map volume. This is done by counting the points, and multiplying that by voxels’ volume.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">can be called only after <a class="reference internal" href="#density.Density.place_points" title="density.Density.place_points"><code class="xref py py-func docutils literal"><span class="pre">place_points</span></code></a> has been called.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">supposes unskewed voxels.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="density.Density.import_map">
<code class="descname">import_map</code><span class="sig-paren">(</span><em>filename</em>, <em>fileformat='dx'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/density.html#Density.import_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#density.Density.import_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Import density map and fill up the points and properties data structures.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> – name of density file to load</li>
<li><strong>fileformat</strong> – at the moment supports dx, ccp4, mrc and imod</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="density.Density.import_numpy">
<code class="descname">import_numpy</code><span class="sig-paren">(</span><em>data, origin=[0, 0, 0], delta=array([[ 1.,  0.,  0.],        [ 0.,  1.,  0.],        [ 0.,  0.,  1.]])</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/density.html#Density.import_numpy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#density.Density.import_numpy" title="Permalink to this definition">¶</a></dt>
<dd><p>import a numpy 3D array to allow manipulation as a density map</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> – numpy 3D array</li>
<li><strong>origin</strong> – coordinates of bottom left corner of the map</li>
<li><strong>delta</strong> – voxels’ shape (default is a cubic voxel of 1 Angstrom-long sides).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="density.Density.place_points">
<code class="descname">place_points</code><span class="sig-paren">(</span><em>sigma=0</em>, <em>noise_filter=0.01</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/density.html#Density.place_points"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#density.Density.place_points" title="Permalink to this definition">¶</a></dt>
<dd><p>given density information, place points on every voxel above a given threshold.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sigma</strong> – intensity threshold value.</li>
<li><strong>noise_filter</strong> – launch DBSCAN clustering algorithm to detect connected regions in density map. Regions representing less than noise_filter of the total will be removed. This is a ratio, value should be between 0 and 1.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="density.Density.return_density_map">
<code class="descname">return_density_map</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/density.html#Density.return_density_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#density.Density.return_density_map" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">density map as 3D numpy array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="density.Density.scan_threshold">
<code class="descname">scan_threshold</code><span class="sig-paren">(</span><em>mass</em>, <em>density=0.782878356</em>, <em>sampling_points=1000</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/density.html#Density.scan_threshold"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#density.Density.scan_threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>if mass and density of object are known, filter the map on a linear scale of threshold values, and compare the obtained mass to the experimental one.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">in proteins, an average value of 1.3 g/cm^3 (0.782878356 Da/A^3) can be assumed. Alternatively, the relation density=1.410+0.145*exp(-mass(kDa)/13) can be used.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">1 Da/A^3=0.602214120 g/cm^3</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mass</strong> – target mass in Da</li>
<li><strong>density</strong> – target density in Da/A^3</li>
<li><strong>sampling_points</strong> – number of measures to perform between min and max intensity in density map</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">array reporting tested values and error on mass ([threshold, model_mass-target_mass])</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="density.Density.threshold_vol_ccs">
<code class="descname">threshold_vol_ccs</code><span class="sig-paren">(</span><em>low=''</em>, <em>high=''</em>, <em>sampling_points=1000</em>, <em>append=False</em>, <em>noise_filter=0.01</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/density.html#Density.threshold_vol_ccs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#density.Density.threshold_vol_ccs" title="Permalink to this definition">¶</a></dt>
<dd><p>return the volume to threshold to CCS relationship</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sampling_points</strong> – number of measures to perform between min and max intensity in density map</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">array reporting tested values and error on mass ([threshold, model_mass-target_mass])</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="density.Density.write_dx">
<code class="descname">write_dx</code><span class="sig-paren">(</span><em>fname='dens.dx'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/density.html#Density.write_dx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#density.Density.write_dx" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a density map in DX format</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>fname</strong> – output file name</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Single Structures</a><ul>
<li><a class="reference internal" href="#module-structure">Structure</a></li>
<li><a class="reference internal" href="#module-molecule">Molecule</a></li>
<li><a class="reference internal" href="#convex-point-clouds">Convex Point Clouds</a></li>
<li><a class="reference internal" href="#module-density">Density</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">BiobOx’s documentation</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="assembly.html"
                        title="next chapter">Assemblies</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/structure.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="assembly.html" title="Assemblies"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="BiobOx’s documentation"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">biobox 1.0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Matteo Degiacomi.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.3.
    </div>
  </body>
</html>