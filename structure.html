<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Single Structures &#8212; biobox 1.0 documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Assemblies" href="assembly.html" />
    <link rel="prev" title="BiobOx’s documentation" href="index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="assembly.html" title="Assemblies"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="BiobOx’s documentation"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">biobox 1.0 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="single-structures">
<h1>Single Structures<a class="headerlink" href="#single-structures" title="Permalink to this headline">¶</a></h1>
<p>The main data structure in BiobOx is the <a class="reference internal" href="#structure.Structure" title="structure.Structure"><code class="xref py py-func docutils literal"><span class="pre">Structure</span></code></a> class, which handles collections of 3D points.
Points are stored in a MxNx3 <strong>coordinates array</strong>, where M is the number of alternative points arrangements, and N is the amount of points.</p>
<p>At any moment, one of the loaded points conformations is considered to be the active one (a.k.a. <strong>current</strong>).
Any rototranslation or measuring operation will be performed on the current structure only.
Some methods, e.g. <a class="reference internal" href="#structure.Structure.rmsd" title="structure.Structure.rmsd"><code class="xref py py-func docutils literal"><span class="pre">rmsd</span></code></a> allow comparing different conformations, independently from which is the current one.</p>
<p>The current conformation in the coordinates array can be changed by calling the <a class="reference internal" href="#structure.Structure.set_current" title="structure.Structure.set_current"><code class="xref py py-func docutils literal"><span class="pre">set_current</span></code></a> method (altering the Structure&#8217;s <strong>current</strong> attribute).
For comfort, the current conformation is accessible in the <strong>points</strong> Nx3 array, where:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">current</span><span class="p">]</span>
</pre></div>
</div>
<p>Points attributes are stored in a pandas <strong>dataframe</strong>. For instance, self.data[&#8220;radius&#8221;] contains each point&#8217;s radius.
A property of the whole point cloud can be stored in a properties dictionary (e.g. self.properties[&#8220;center&#8221;]).</p>
<p>Several <a class="reference internal" href="#structure.Structure" title="structure.Structure"><code class="xref py py-func docutils literal"><span class="pre">Structure</span></code></a> subclasses are available (<a class="reference internal" href="#molecule.Molecule" title="molecule.Molecule"><code class="xref py py-func docutils literal"><span class="pre">Molecule</span></code></a>, <a class="reference internal" href="#convex.Ellipsoid" title="convex.Ellipsoid"><code class="xref py py-func docutils literal"><span class="pre">Ellipsoid</span></code></a>, <a class="reference internal" href="#convex.Cylinder" title="convex.Cylinder"><code class="xref py py-func docutils literal"><span class="pre">Cylinder</span></code></a>, <a class="reference internal" href="#convex.Cone" title="convex.Cone"><code class="xref py py-func docutils literal"><span class="pre">Cone</span></code></a>, <a class="reference internal" href="#convex.Sphere" title="convex.Sphere"><code class="xref py py-func docutils literal"><span class="pre">Sphere</span></code></a>, <a class="reference internal" href="#convex.Prism" title="convex.Prism"><code class="xref py py-func docutils literal"><span class="pre">Prism</span></code></a>, <a class="reference internal" href="#density.Density" title="density.Density"><code class="xref py py-func docutils literal"><span class="pre">Density</span></code></a>, see below).</p>
<div class="section" id="module-structure">
<span id="structure"></span><h2>Structure<a class="headerlink" href="#module-structure" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="structure.Structure">
<em class="property">class </em><code class="descname">Structure</code><span class="sig-paren">(</span><em>p=array([]</em>, <em>shape=(2L</em>, <em>0L)</em>, <em>dtype=float64)</em>, <em>r=1.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure" title="Permalink to this definition">¶</a></dt>
<dd><p>A Structure consists of an ensemble of points in 3D space, and metadata associated to each of them.</p>
<p>Point coordinates and properties data structures are first initialized.
properties is a dictionary initially containing an entry for &#8216;center&#8217; (center of geometry) and &#8216;radius&#8217; (average radius of points).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>p</strong> &#8211; coordinates data structure as a mxnx3 numpy array (alternative conformation x atom x 3D coordinate). nx3 numpy array can be supplied, in case a single conformation is present.</li>
<li><strong>r</strong> &#8211; average radius of every point in dataset (float), or radius of every point (numpy array)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="structure.Structure.add_xyz">
<code class="descname">add_xyz</code><span class="sig-paren">(</span><em>coords</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.add_xyz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.add_xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>add a new alternative conformation to the database</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>coords</strong> &#8211; array of 3D points, or array of arrays of 3D points (in case multiple alternative coordinates must be added at the same time)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.align_axes">
<code class="descname">align_axes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.align_axes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.align_axes" title="Permalink to this definition">¶</a></dt>
<dd><p>Align structure on its principal axes.</p>
<p>First principal axis aligned along x, second along y and third along z.</p>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.apply_transformation">
<code class="descname">apply_transformation</code><span class="sig-paren">(</span><em>M</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.apply_transformation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.apply_transformation" title="Permalink to this definition">¶</a></dt>
<dd><p>apply a 3x3 transformation matrix</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>M</strong> &#8211; 3x3 transformation matrix (2D numpy array)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.center_to_origin">
<code class="descname">center_to_origin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.center_to_origin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.center_to_origin" title="Permalink to this definition">¶</a></dt>
<dd><p>move the structure so that its center of geometry is at the origin.</p>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.clear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>remove all the coordinates and empty metadata</p>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.convex_hull">
<code class="descname">convex_hull</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.convex_hull"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.convex_hull" title="Permalink to this definition">¶</a></dt>
<dd><p>compute Structure&#8217;s convex Hull using QuickHull algorithm.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Qhull available only on scipy &gt;=0.12</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><a class="reference internal" href="#structure.Structure" title="structure.Structure"><code class="xref py py-func docutils literal"><span class="pre">Structure</span></code></a> object, containing the coordinates of vertices composing the convex hull</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="structure.Structure.coordinates">
<code class="descname">coordinates</code><em class="property"> = None</em><a class="headerlink" href="#structure.Structure.coordinates" title="Permalink to this definition">¶</a></dt>
<dd><p>numpy array containing an ensemble of alternative coordinates in 3D space</p>
</dd></dl>

<dl class="attribute">
<dt id="structure.Structure.current">
<code class="descname">current</code><em class="property"> = None</em><a class="headerlink" href="#structure.Structure.current" title="Permalink to this definition">¶</a></dt>
<dd><p>index of currently selected conformation</p>
</dd></dl>

<dl class="attribute">
<dt id="structure.Structure.data">
<code class="descname">data</code><em class="property"> = None</em><a class="headerlink" href="#structure.Structure.data" title="Permalink to this definition">¶</a></dt>
<dd><p>metadata about each atom (pandas Dataframe)</p>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.delete_xyz">
<code class="descname">delete_xyz</code><span class="sig-paren">(</span><em>index</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.delete_xyz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.delete_xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>remove one conformation from the conformations database.</p>
<p>the new current conformation will be the previous one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>index</strong> &#8211; alternative coordinates set to remove</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.get_center">
<code class="descname">get_center</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.get_center"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.get_center" title="Permalink to this definition">¶</a></dt>
<dd><p>compute protein center of geometry (also assigns it to self.properties[&#8220;center&#8221;] key).</p>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.get_density">
<code class="descname">get_density</code><span class="sig-paren">(</span><em>step=1.0</em>, <em>sigma=1.0</em>, <em>kernel_half_width=5</em>, <em>buff=3</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.get_density"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.get_density" title="Permalink to this definition">¶</a></dt>
<dd><p>generate density map from points</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>step</strong> &#8211; size of cubic voxels, in Angstrom</li>
<li><strong>sigma</strong> &#8211; gaussian kernel sigma</li>
<li><strong>kernel_half_width</strong> &#8211; kernel half width, in voxels</li>
<li><strong>buff</strong> &#8211; padding to add at points cloud boundaries</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#density.Density" title="density.Density"><code class="xref py py-func docutils literal"><span class="pre">Density</span></code></a> object, containing a simulated density map</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.get_principal_axes">
<code class="descname">get_principal_axes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.get_principal_axes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.get_principal_axes" title="Permalink to this definition">¶</a></dt>
<dd><p>compute Structure&#8217;s principal axes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">3x3 numpy array, containing the 3 principal axes ranked from smallest to biggest.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.get_size">
<code class="descname">get_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.get_size"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.get_size" title="Permalink to this definition">¶</a></dt>
<dd><p>compute the dimensions of the object along x, y and z.</p>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.get_xyz">
<code class="descname">get_xyz</code><span class="sig-paren">(</span><em>indices=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.get_xyz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.get_xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>get points coordinates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>indices</strong> &#8211; indices of points to select. If none is provided, all points coordinates are returned.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">coordinates of all points indexed by the provided indices list, or all of them if no list is provided.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.pca">
<code class="descname">pca</code><span class="sig-paren">(</span><em>indices=-1</em>, <em>project_thresh=-1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.pca"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.pca" title="Permalink to this definition">¶</a></dt>
<dd><p>compute Principal Components Analysis (PCA) on specific points within all the alternative coordinates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>indices</strong> &#8211; points indices to be considered for PCA</li>
<li><strong>project_thresh</strong> &#8211; <p>eigenvectors energy value [0,1]. Determines how many vectors are relevant to describe the points main motions,</p>
<p>the higher value, the larger the amount of selected eigenvectors. Every alternative coordinate will be projected in the selected sub-eigenspace.</p>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">numpy array of ranked eigenvalues</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">numpy array of eigenvectors, ranked according to their eigenvalue</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">optionally returned, when project_thresh is provided as input</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="structure.Structure.points">
<code class="descname">points</code><em class="property"> = None</em><a class="headerlink" href="#structure.Structure.points" title="Permalink to this definition">¶</a></dt>
<dd><p>pointer to currently selected conformation</p>
</dd></dl>

<dl class="attribute">
<dt id="structure.Structure.properties">
<code class="descname">properties</code><em class="property"> = None</em><a class="headerlink" href="#structure.Structure.properties" title="Permalink to this definition">¶</a></dt>
<dd><p>collection of properties. By default, &#8216;center&#8217; (geometric center of the Structure) is defined</p>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.rmsd">
<code class="descname">rmsd</code><span class="sig-paren">(</span><em>i</em>, <em>j</em>, <em>points_index=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.rmsd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.rmsd" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the RMSD between two structures in alternative coordinates ensemble.
uses Kabsch alignement algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>i</strong> &#8211; index of the first structure</li>
<li><strong>j</strong> &#8211; index of the second structure</li>
<li><strong>points_index</strong> &#8211; if set, only specific points will be considered for comparison</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">RMSD of the two structures</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.rmsd_distance_matrix">
<code class="descname">rmsd_distance_matrix</code><span class="sig-paren">(</span><em>points_index=[]</em>, <em>flat=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.rmsd_distance_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.rmsd_distance_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>compute distance matrix between structures (using RMSD as metric).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>points_index</strong> &#8211; if set, only specific points will be considered for comparison</li>
<li><strong>flat</strong> &#8211; if True, returns flattened distance matrix</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">RMSD distance matrix</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.rmsd_one_vs_all">
<code class="descname">rmsd_one_vs_all</code><span class="sig-paren">(</span><em>ref_index</em>, <em>points_index=[]</em>, <em>align=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.rmsd_one_vs_all"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.rmsd_one_vs_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the RMSD between all structures with respect of a reference structure.
uses Kabsch alignement algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ref_index</strong> &#8211; index of reference structure in conformations database</li>
<li><strong>points_index</strong> &#8211; if set, only specific points will be considered for comparison</li>
<li><strong>align</strong> &#8211; if set to true, all conformations will be aligned to reference (note: cannot be undone!)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">RMSD of all structures with respect of reference structure (in a numpy array)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.rmsf">
<code class="descname">rmsf</code><span class="sig-paren">(</span><em>indices=-1</em>, <em>step=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.rmsf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.rmsf" title="Permalink to this definition">¶</a></dt>
<dd><p>compute Root Mean Square Fluctuation (RMSF) of selected atoms.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>indices</strong> &#8211; indices of points for which RMSF will be calculated. If no indices list is provided, RMSF of all points will be calculated.</li>
<li><strong>step</strong> &#8211; timestep between two conformations (useful when using conformations extracted from molecular dynamics)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">numpy aray with RMSF of all provided indices, in the same order</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.rotate">
<code class="descname">rotate</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.rotate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>rotate the structure provided angles of rotation around x, y and z axes (in degrees).</p>
<p>This is a rotation with respect of the origin.
Make sure that the center of your structure is at the origin, if you don&#8217;t want to get a translation as well!
rotating an object being not centered requires to first translate the ellipsoid at the origin, rotate it, and bringing it back.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> &#8211; rotation around x axis</li>
<li><strong>y</strong> &#8211; rotation around y axis</li>
<li><strong>z</strong> &#8211; rotation around z axis</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.rotation_matrix">
<code class="descname">rotation_matrix</code><span class="sig-paren">(</span><em>axis</em>, <em>theta</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.rotation_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.rotation_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>compute matrix needed to rotate the system around an arbitrary axis (using Euler-Rodrigues formula).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>axis</strong> &#8211; 3d vector (numpy array), representing the axis around which to rotate</li>
<li><strong>theta</strong> &#8211; desired rotation angle</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">3x3 rotation matrix</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.set_current">
<code class="descname">set_current</code><span class="sig-paren">(</span><em>pos</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.set_current"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.set_current" title="Permalink to this definition">¶</a></dt>
<dd><p>select current frame (place frame pointer at desired position)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>pos</strong> &#8211; number of alternative conformation (starting from 0)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.set_xyz">
<code class="descname">set_xyz</code><span class="sig-paren">(</span><em>coords</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.set_xyz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.set_xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>set point coordinates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>coords</strong> &#8211; array of 3D points</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.translate">
<code class="descname">translate</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.translate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.translate" title="Permalink to this definition">¶</a></dt>
<dd><p>translate the whole structure by a given amount.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> &#8211; translation around x axis</li>
<li><strong>y</strong> &#8211; translation around y axis</li>
<li><strong>z</strong> &#8211; translation around z axis</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="structure.Structure.write_pdb">
<code class="descname">write_pdb</code><span class="sig-paren">(</span><em>filename</em>, <em>index=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/structure.html#Structure.write_pdb"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#structure.Structure.write_pdb" title="Permalink to this definition">¶</a></dt>
<dd><p>write a multi PDB file where every point is a sphere. VdW radius is written into beta factor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> &#8211; name of file to output</li>
<li><strong>index</strong> &#8211; list of frame indices to write to file. By default, a multipdb with all frames will be produced.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-molecule">
<span id="molecule"></span><h2>Molecule<a class="headerlink" href="#module-molecule" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="molecule.Molecule">
<em class="property">class </em><code class="descname">Molecule</code><a class="reference internal" href="_modules/molecule.html#Molecule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">biobox.classes.structure.Structure</span></code></p>
<p>Subclass of <a class="reference internal" href="#structure.Structure" title="structure.Structure"><code class="xref py py-func docutils literal"><span class="pre">Structure</span></code></a>, allows reading, manipulating and analyzing molecular structures.</p>
<p>At instantiation, properties associated to every individual atoms are stored in a pandas Dataframe self.data.
The columns of the self.data have the following names:
atom, index, name, resname, chain, resid, beta, occupancy, atomtype, radius, charge.</p>
<p>self.knowledge contains a knowledge base about atoms and residues properties. Default values are:</p>
<ul class="simple">
<li>&#8216;residue_mass&#8217; property stores the average mass for most common aminoacids (values from Expasy website)</li>
<li>&#8216;atom_vdw&#8217; vdw radius of common atoms</li>
<li>&#8216;atom_mass&#8217; mass of common atoms</li>
</ul>
<p>The knowledge base can be edited. For instance, to add information about residue &#8220;TST&#8221; mass in molecule M type: M.knowledge[&#8216;mass_residue&#8217;][&#8220;TST&#8221;]=142.42</p>
<dl class="method">
<dt id="molecule.Molecule.apply_biomatrix">
<code class="descname">apply_biomatrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.apply_biomatrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.apply_biomatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>if biomatrix information is provided, generate a new molecule with all symmetry operators applied.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">new Molecule containing several copies of the current Molecule, arranged according to BIOMT statements contained in pdb, or -1 if no transformation matrix is provided</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.apply_symmetry">
<code class="descname">apply_symmetry</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.apply_symmetry"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.apply_symmetry" title="Permalink to this definition">¶</a></dt>
<dd><p>if symmetry information is provided, generate a new molecule with all symmetry operators applied.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">new Molecule containing several copies of the current Molecule, arranged according to SMTRY statements contained in pdb, or -1 if no transformation matrix is provided</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.assign_atomtype">
<code class="descname">assign_atomtype</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.assign_atomtype"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.assign_atomtype" title="Permalink to this definition">¶</a></dt>
<dd><p>guess atomtype from atom names</p>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.atomignore">
<code class="descname">atomignore</code><span class="sig-paren">(</span><em>chain</em>, <em>res</em>, <em>atom</em>, <em>get_index=False</em>, <em>use_resname=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.atomignore"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.atomignore" title="Permalink to this definition">¶</a></dt>
<dd><p>Select specific atoms that do not match a specific query (chain, residue ID and atom name).
Useful to remove from a molecule atoms unwanted for further analysis, alternative conformations, etc...</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>chain</strong> &#8211; chain name (accepts * as wildcard). Can also be a list or numpy array of strings.</li>
<li><strong>res</strong> &#8211; residue ID (accepts * as wildcard). Can also be a list or numpy array of of int.</li>
<li><strong>atom</strong> &#8211; atom name (accepts * as wildcard). Can also be a list or numpy array of strings.</li>
<li><strong>get_index</strong> &#8211; if set to True, returns the indices of atoms in self.points array (and self.properties[&#8216;data&#8217;])</li>
<li><strong>use_resname</strong> &#8211; if set to True, consider information in &#8220;res&#8221; variable as resnames, and not resids</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">coordinates of the selected points not matching the query, if get_index is set to true, their indices in self.points array.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.atomselect">
<code class="descname">atomselect</code><span class="sig-paren">(</span><em>chain</em>, <em>res</em>, <em>atom</em>, <em>get_index=False</em>, <em>use_resname=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.atomselect"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.atomselect" title="Permalink to this definition">¶</a></dt>
<dd><p>Select specific atoms in the protein providing chain, residue ID and atom name.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>chain</strong> &#8211; selection of a specific chain name (accepts * as wildcard). Can also be a list or numpy array of strings.</li>
<li><strong>res</strong> &#8211; residue ID of desired atoms (accepts * as wildcard). Can also be a list or numpy array of of int.</li>
<li><strong>atom</strong> &#8211; name of desired atom (accepts * as wildcard). Can also be a list or numpy array of strings.</li>
<li><strong>get_index</strong> &#8211; if set to True, returns the indices of selected atoms in self.points array (and self.properties[&#8216;data&#8217;])</li>
<li><strong>use_resname</strong> &#8211; if set to True, consider information in &#8220;res&#8221; variable as resnames, and not resids</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">coordinates of the selected points and, if get_index is set to true, their indices in self.points array.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.beta_factor_from_rmsf">
<code class="descname">beta_factor_from_rmsf</code><span class="sig-paren">(</span><em>indices=-1</em>, <em>step=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.beta_factor_from_rmsf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.beta_factor_from_rmsf" title="Permalink to this definition">¶</a></dt>
<dd><p>estimate atoms beta factor on the base of their RMSF.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>indices</strong> &#8211; indices of atoms of interest. If not set all atoms will be considered.</li>
<li><strong>step</strong> &#8211; timestep between two conformations (useful when using conformations extracted from molecular dynamics)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.get_atoms_ccs">
<code class="descname">get_atoms_ccs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.get_atoms_ccs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.get_atoms_ccs" title="Permalink to this definition">¶</a></dt>
<dd><p>return array with atomic CCS radii of every atom in molecule</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">CCS in Angstrom^2</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.get_couples">
<code class="descname">get_couples</code><span class="sig-paren">(</span><em>idx</em>, <em>cutoff</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.get_couples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.get_couples" title="Permalink to this definition">¶</a></dt>
<dd><p>given a list of indices, compute the all-vs-all distance and return only couples below a given cutoff distance</p>
<p>useful for the detection of disulfide bridges or linkable sites via cross-linking (approximation, supposing euclidean distances)&#8217;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>idx</strong> &#8211; indices of atoms to check.</li>
<li><strong>cutoff</strong> &#8211; minimal distance to consider a couple as linkable.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">nx3 numpy array containing, for every valid connection, id of first atom, id of second atom and distance between the two.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.get_electrostatics">
<code class="descname">get_electrostatics</code><span class="sig-paren">(</span><em>step=1.0</em>, <em>buff=3</em>, <em>threshold=0.01</em>, <em>vdw_kernel_half_width=5</em>, <em>elect_kernel_half_width=12</em>, <em>chain='*'</em>, <em>clear_mass=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.get_electrostatics"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.get_electrostatics" title="Permalink to this definition">¶</a></dt>
<dd><p>generate electrostatics map from points</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>step</strong> &#8211; size of cubic voxels, in Angstrom</li>
<li><strong>buff</strong> &#8211; padding to add at points cloud boundaries</li>
<li><strong>threshold</strong> &#8211; Threshold used for removing mass occupied space from the electron density map</li>
<li><strong>vdw_kernel_half_width</strong> &#8211; kernel half width, in voxels</li>
<li><strong>elect_kernel_half_width</strong> &#8211; kernel half width, in voxels</li>
<li><strong>chain</strong> &#8211; select chain to use, default all chains</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">positive <a class="reference internal" href="#density.Density" title="density.Density"><code class="xref py py-func docutils literal"><span class="pre">Density</span></code></a> object</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">negative <a class="reference internal" href="#density.Density" title="density.Density"><code class="xref py py-func docutils literal"><span class="pre">Density</span></code></a> object</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">mass density object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.get_mass_by_atom">
<code class="descname">get_mass_by_atom</code><span class="sig-paren">(</span><em>skip_resname=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.get_mass_by_atom"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.get_mass_by_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>compute protein mass using atoms in pdb</p>
<p>sum the mass of all atoms (using a knowledge base of atom masses in Dalton)
The knowledge base can be expanded or edited by adding or editing entries to the molecule&#8217;s mass dictionary, e.g. to add the atom &#8220;PI&#8221; mass in molecule M type: M.knowledge[&#8216;atom_mass&#8217;][&#8220;PI&#8221;]=3.141592</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>skip_resname</strong> &#8211; list of resnames to skip. Useful to exclude ions water or other ligands from the calculation.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">mass of molecule in Dalton</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.get_mass_by_residue">
<code class="descname">get_mass_by_residue</code><span class="sig-paren">(</span><em>skip_resname=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.get_mass_by_residue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.get_mass_by_residue" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute protein mass using residues (i.e. account also for atoms not present in the structure)</p>
<p>Sum the average mass all every residue (using a knowledge base of atom masses in Dalton)
The knowledge base can be expanded or edited by adding entries to the molecule&#8217;s mass dictionary, e.g. to add the residue &#8220;TST&#8221; mass in molecule M type: M.knowledge[&#8216;mass_residue&#8217;][&#8220;TST&#8221;]=142.42</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>skip_resname</strong> &#8211; list of resnames to skip. Useful to exclude ions water or other ligands from the calculation.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">mass of molecule in Dalton</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.get_pdb_data">
<code class="descname">get_pdb_data</code><span class="sig-paren">(</span><em>index=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.get_pdb_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.get_pdb_data" title="Permalink to this definition">¶</a></dt>
<dd><p>aggregate data and point coordinates, and return in a unique data structure</p>
<p>Returned data is a list containing strings for points data and floats for point coordinates
in the same order as a pdb file, i.e.
ATOM/HETATM, index, name, resname, chain name, residue ID, x, y, z, occupancy, beta factor, atomtype.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list aggregated data and coordinates for every point, as string.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.get_subset">
<code class="descname">get_subset</code><span class="sig-paren">(</span><em>idxs</em>, <em>conformations=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.get_subset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.get_subset" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <a class="reference internal" href="#molecule.Molecule" title="molecule.Molecule"><code class="xref py py-func docutils literal"><span class="pre">Molecule</span></code></a> object containing only the selected atoms and frames</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ixds</strong> &#8211; atoms to extract</li>
<li><strong>conformations</strong> &#8211; frames to extract (by default, all)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#molecule.Molecule" title="molecule.Molecule"><code class="xref py py-func docutils literal"><span class="pre">Molecule</span></code></a> object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.get_vdw_density">
<code class="descname">get_vdw_density</code><span class="sig-paren">(</span><em>buff=3</em>, <em>step=0.5</em>, <em>kernel_half_width=10</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.get_vdw_density"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.get_vdw_density" title="Permalink to this definition">¶</a></dt>
<dd><p>generate density map from points based on the van der Waals readius of the atoms</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>buff</strong> &#8211; Buffer used to create the boundaries of the density map</li>
<li><strong>step</strong> &#8211; Stepsize for creating the density object</li>
<li><strong>kernel_half_width</strong> &#8211; Kernel half width of the gaussian kernel, will be scaled by atom specific sigma</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#density.Density" title="density.Density"><code class="xref py py-func docutils literal"><span class="pre">Density</span></code></a> object, containing a density map</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.guess_chain_split">
<code class="descname">guess_chain_split</code><span class="sig-paren">(</span><em>distance=3</em>, <em>use_backbone=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.guess_chain_split"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.guess_chain_split" title="Permalink to this definition">¶</a></dt>
<dd><p>reassign chain name, using distance cutoff (cannot be undone).
If two consecutive atoms are beyond a cutoff, a new chain is assigned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>distance</strong> &#8211; distance cutoff distance</li>
<li><strong>use_backbone</strong> &#8211; if True, splitting will be performed considering backbone atoms (N and C), all atoms in a sequence otherwise</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.import_gro">
<code class="descname">import_gro</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.import_gro"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.import_gro" title="Permalink to this definition">¶</a></dt>
<dd><p>read a gro possibly containing multiple structures.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> &#8211; name of .gro file to import</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.import_pdb">
<code class="descname">import_pdb</code><span class="sig-paren">(</span><em>pdb</em>, <em>include_hetatm=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.import_pdb"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.import_pdb" title="Permalink to this definition">¶</a></dt>
<dd><p>read a pdb (possibly containing containing multiple models).</p>
<p>Models are split according to ENDMDL and END statement.
All alternative coordinates are expected to have the same atoms.
After loading, the first model (M.current_model=0) will be set as active.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pdb</strong> &#8211; PDB filename</li>
<li><strong>include_hetatm</strong> &#8211; if True, HETATM will be included (they get skipped if False)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.import_pqr">
<code class="descname">import_pqr</code><span class="sig-paren">(</span><em>pqr</em>, <em>include_hetatm=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.import_pqr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.import_pqr" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a pqr (possibly containing containing multiple models).</p>
<p>models are split according to ENDMDL and END statement.
All alternative coordinates are expected to have the same atoms.
After loading, the first model (M.current_model=0) will be set as active.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pqr</strong> &#8211; PQR filename</li>
<li><strong>include_hetatm</strong> &#8211; if True, HETATM will be included (they get skipped if False)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.know">
<code class="descname">know</code><span class="sig-paren">(</span><em>prop</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.know"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.know" title="Permalink to this definition">¶</a></dt>
<dd><p>return information from knowledge base</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>prop</strong> &#8211; desired property to extract from knowledge base</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">value associated to requested property, or nan if failed</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.query">
<code class="descname">query</code><span class="sig-paren">(</span><em>query_text</em>, <em>get_index=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.query"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.query" title="Permalink to this definition">¶</a></dt>
<dd><p>## select specific atoms in a multimer un the basis of a text query.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>query_text</strong> &#8211; string selecting atoms of interest. Uses the pandas query syntax, can access all columns in the dataframe self.data.</li>
<li><strong>get_index</strong> &#8211; if set to True, returns the indices of selected atoms in self.points array (and self.data)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">coordinates of the selected points (in a unique array) and, if get_index is set to true, a list of their indices in subunits&#8217; self.points array.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.rmsf_from_beta_factor">
<code class="descname">rmsf_from_beta_factor</code><span class="sig-paren">(</span><em>indices=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.rmsf_from_beta_factor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.rmsf_from_beta_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate RMSF from atoms beta factors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>indices</strong> &#8211; indices of atoms of interest. If not set all atoms will be considered.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.s2">
<code class="descname">s2</code><span class="sig-paren">(</span><em>atomname1='N'</em>, <em>atomname2='H'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.s2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.s2" title="Permalink to this definition">¶</a></dt>
<dd><p>compute s2, given two atoms defining the vector of interest.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>atomname1</strong> &#8211; name of the first atom</li>
<li><strong>atomname2</strong> &#8211; name of the second atom</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">data numpy array containing information about residues for which measuring has been performed (i.e.[chain, resid])</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">s2 s2 of residues for which both provided input atoms have been found</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.same_residue">
<code class="descname">same_residue</code><span class="sig-paren">(</span><em>index</em>, <em>get_index=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.same_residue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.same_residue" title="Permalink to this definition">¶</a></dt>
<dd><p>Select atoms having the same residue and chain as a given atom (or list of atoms)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>indices</strong> (<em>index</em>) &#8211; of atoms of choice (integer of list of integers)</li>
<li><strong>get_index</strong> &#8211; if set to True, returns the indices of selected atoms in self.points array (and self.properties[&#8216;data&#8217;])</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">coordinates of the selected points and, if get_index is set to true, their indices in self.points array.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.same_residue_unique">
<code class="descname">same_residue_unique</code><span class="sig-paren">(</span><em>index</em>, <em>get_index=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.same_residue_unique"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.same_residue_unique" title="Permalink to this definition">¶</a></dt>
<dd><p>Select atoms having the same residue and chain as a given atom (or list of atoms)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>index</strong> &#8211; indices of atoms of choice (integer of list of integers)</li>
<li><strong>get_index</strong> &#8211; if set to True, returns the indices of selected atoms in self.points array (and self.properties[&#8216;data&#8217;])</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">coordinates of the selected points and, if get_index is set to true, their indices in self.points array.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.write_gro">
<code class="descname">write_gro</code><span class="sig-paren">(</span><em>outname</em>, <em>conformations=[]</em>, <em>index=''</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.write_gro"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.write_gro" title="Permalink to this definition">¶</a></dt>
<dd><p>write structure(s) in .gro format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>outname</strong> &#8211; name of .gro file to be generated.</li>
<li><strong>index</strong> &#8211; indices of atoms to write to file. If empty, all atoms are returned. Index values obtaineable with a call like: index=molecule.atomselect(&#8220;A&#8221;, [1, 2, 3], &#8220;CA&#8221;, True)[1]</li>
<li><strong>conformations</strong> &#8211; list of conformation indices to write to file. By default, all conformations will be returned.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="molecule.Molecule.write_pdb">
<code class="descname">write_pdb</code><span class="sig-paren">(</span><em>outname</em>, <em>conformations=[]</em>, <em>index=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/molecule.html#Molecule.write_pdb"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#molecule.Molecule.write_pdb" title="Permalink to this definition">¶</a></dt>
<dd><p>overload superclass method for writing (multi)pdb.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>outname</strong> &#8211; name of pdb file to be generated.</li>
<li><strong>index</strong> &#8211; indices of atoms to write to file. If empty, all atoms are returned. Index values obtaineable with a call like: index=molecule.atomselect(&#8220;A&#8221;, [1, 2, 3], &#8220;CA&#8221;, True)[1]</li>
<li><strong>conformations</strong> &#8211; list of conformation indices to write to file. By default, a multipdb with all conformations will be produced.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="convex-point-clouds">
<h2>Convex Point Clouds<a class="headerlink" href="#convex-point-clouds" title="Permalink to this headline">¶</a></h2>
<p>The following classes allow generating clouds of points arranged according to specific (convex) geometries.
All these classes are subclass of <a class="reference internal" href="#structure.Structure" title="structure.Structure"><code class="xref py py-func docutils literal"><span class="pre">Structure</span></code></a>.</p>
<span class="target" id="module-convex"></span><dl class="class">
<dt id="convex.Cone">
<em class="property">class </em><code class="descname">Cone</code><span class="sig-paren">(</span><em>r</em>, <em>h</em>, <em>skew=0</em>, <em>radius=1.1</em>, <em>pts_density_r=0.09817477042468103</em>, <em>pts_density_h=0.2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Cone"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Cone" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">biobox.classes.structure.Structure</span></code></p>
<p>Create an ensemble of points arranged as a cone.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>r</strong> &#8211; radius</li>
<li><strong>h</strong> &#8211; height</li>
<li><strong>skew</strong> &#8211; skewing with respect of vertical axis</li>
<li><strong>radius</strong> &#8211; size of the individual points composing it</li>
<li><strong>pts_density_r</strong> &#8211; density of points along the rotation axis (using parametric function for cylinder)</li>
<li><strong>pts_density_h</strong> &#8211; density of points along height (using parametric function for cylinder)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="convex.Cone.ccs">
<code class="descname">ccs</code><span class="sig-paren">(</span><em>gas=1.4</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Cone.ccs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Cone.ccs" title="Permalink to this definition">¶</a></dt>
<dd><p>compute cone CCS (use analytical solution using surface and gas effect)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">CCS in A^2</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="convex.Cone.get_surface">
<code class="descname">get_surface</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Cone.get_surface"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Cone.get_surface" title="Permalink to this definition">¶</a></dt>
<dd><p>compute cone surface.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">surface in A^2</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="convex.Cone.get_volume">
<code class="descname">get_volume</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Cone.get_volume"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Cone.get_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute cone volume.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">volume in A^3</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="convex.Cylinder">
<em class="property">class </em><code class="descname">Cylinder</code><span class="sig-paren">(</span><em>r</em>, <em>h</em>, <em>squeeze=1.0</em>, <em>skew=0.0</em>, <em>radius=1.1</em>, <em>pts_density_u=0.09817477042468103</em>, <em>pts_density_h=0.2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Cylinder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Cylinder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">biobox.classes.structure.Structure</span></code></p>
<p>Create an ensemble of points arranged as an elliptical cylinder.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>r</strong> &#8211; radius</li>
<li><strong>h</strong> &#8211; height</li>
<li><strong>squeeze</strong> &#8211; create an elliptical base, having axes equal to r and squeeze*r</li>
<li><strong>skew</strong> &#8211; skewing with respect of vertical axis</li>
<li><strong>radius</strong> &#8211; size of the individual points composing it</li>
<li><strong>density</strong> (<em>pts_density_h</em>) &#8211; of points along the u angle (using parametric function for cylinder)</li>
<li><strong>density</strong> &#8211; of points along the v angle (using parametric function for cylinder)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="convex.Cylinder.ccs">
<code class="descname">ccs</code><span class="sig-paren">(</span><em>gas=1.4</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Cylinder.ccs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Cylinder.ccs" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute cylinder CCS.</p>
<p>Uses Ramanujan approximation for base perimeter. Good, but not perfect for very elliptical cylinders!</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">CCS in A^2</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="convex.Cylinder.get_surface">
<code class="descname">get_surface</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Cylinder.get_surface"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Cylinder.get_surface" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute cylinder surface.</p>
<p>Uses Ramanujan approximation for base perimeter. Good, but not perfect for very elliptical cylinders!</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">surface in A^2</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="convex.Cylinder.get_volume">
<code class="descname">get_volume</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Cylinder.get_volume"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Cylinder.get_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute cylinder volume.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">volume in A^3</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="convex.Ellipsoid">
<em class="property">class </em><code class="descname">Ellipsoid</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>c</em>, <em>radius=1.9</em>, <em>pts_density_u=0.08726646259971647</em>, <em>pts_density_v=0.08726646259971647</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Ellipsoid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Ellipsoid" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">biobox.classes.structure.Structure</span></code></p>
<p>Create an ensemble of points arranged as an ellipsoid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> &#8211; x radius of the ellipsoid</li>
<li><strong>b</strong> &#8211; y radius of the ellipsoid</li>
<li><strong>c</strong> &#8211; z radius of the ellipsoid</li>
<li><strong>radius</strong> &#8211; size of the individual points composing it</li>
<li><strong>pts_density_u</strong> &#8211; This parameter defines the density of points along the u angle (using parametric function for ellipsoid)</li>
<li><strong>pts_density_v</strong> &#8211; This parameter defines the density of points along the v angle (using parametric function for ellipsoid)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="convex.Ellipsoid.ccs">
<code class="descname">ccs</code><span class="sig-paren">(</span><em>gas=1.4</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Ellipsoid.ccs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Ellipsoid.ccs" title="Permalink to this definition">¶</a></dt>
<dd><p>compute ellipsoid CCS.</p>
<p>Uses analytical approximation to surface area.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">surface in A^2</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="convex.Ellipsoid.check_inclusion">
<code class="descname">check_inclusion</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Ellipsoid.check_inclusion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Ellipsoid.check_inclusion" title="Permalink to this definition">¶</a></dt>
<dd><p>count how many points in the array p are included in the ellipsoid.</p>
<p>overloading of superclass function, which is slower (here we can use the ellipsoid functional form to speed up things)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>p</strong> &#8211; list of points (numpy array)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">quantity of points located inside the ellipsoid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="convex.Ellipsoid.get_sphericity">
<code class="descname">get_sphericity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Ellipsoid.get_sphericity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Ellipsoid.get_sphericity" title="Permalink to this definition">¶</a></dt>
<dd><p>compute ellipsoid sphericity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">ellipsoid sphericity</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="convex.Ellipsoid.get_surface">
<code class="descname">get_surface</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Ellipsoid.get_surface"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Ellipsoid.get_surface" title="Permalink to this definition">¶</a></dt>
<dd><p>compute ellipsoid surface.</p>
<p>Note: using analytical value, uses analytical approximation to surface area</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">surface in A^2</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="convex.Ellipsoid.get_volume">
<code class="descname">get_volume</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Ellipsoid.get_volume"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Ellipsoid.get_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>compute ellipsoid volume.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">volume in A^3</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="convex.Prism">
<em class="property">class </em><code class="descname">Prism</code><span class="sig-paren">(</span><em>r</em>, <em>h</em>, <em>n</em>, <em>skew=0.0</em>, <em>radius=1.1</em>, <em>pts_density_u=0.09817477042468103</em>, <em>pts_density_h=0.2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Prism"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Prism" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">biobox.classes.structure.Structure</span></code></p>
<p>Create an ensemble of points arranged as a prism (polygonal bottom and top, rectangular sides).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>r</strong> &#8211; distance of sides from center of symmetry</li>
<li><strong>h</strong> &#8211; height</li>
<li><strong>n</strong> &#8211; number of side faces</li>
<li><strong>skew</strong> &#8211; skewing with respect of vertical axis</li>
<li><strong>radius</strong> &#8211; size of the individual points composing it</li>
<li><strong>pts_density_u</strong> &#8211; density of points along the r axis (polar coordinates)</li>
<li><strong>pts_density_h</strong> &#8211; the density of points along the vertical axis</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="convex.Prism.ccs">
<code class="descname">ccs</code><span class="sig-paren">(</span><em>gas=1.4</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Prism.ccs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Prism.ccs" title="Permalink to this definition">¶</a></dt>
<dd><p>compute prism CCS.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">CCS in A^2</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="convex.Prism.get_surface">
<code class="descname">get_surface</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Prism.get_surface"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Prism.get_surface" title="Permalink to this definition">¶</a></dt>
<dd><p>compute prism surface.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">surface in A^2</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="convex.Prism.get_volume">
<code class="descname">get_volume</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Prism.get_volume"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Prism.get_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>compute prism volume.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">volume in A^3</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="convex.Sphere">
<em class="property">class </em><code class="descname">Sphere</code><span class="sig-paren">(</span><em>r</em>, <em>radius=1.9</em>, <em>n_sphere_point=960</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Sphere"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">biobox.classes.structure.Structure</span></code></p>
<p>Create an ensemble of points arranged as a sphere.</p>
<p>using golden spiral to approximate an even distribution</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>r</strong> &#8211; radius of the ellipsoid</li>
<li><strong>radius</strong> &#8211; size of the individual points composing it</li>
<li><strong>n_sphere_point</strong> &#8211; This parameter defines the amount of points in the sphere</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="convex.Sphere.ccs">
<code class="descname">ccs</code><span class="sig-paren">(</span><em>gas=1.4</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Sphere.ccs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Sphere.ccs" title="Permalink to this definition">¶</a></dt>
<dd><p>compute sphere CCS.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">surface in A^2</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="convex.Sphere.check_inclusion">
<code class="descname">check_inclusion</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Sphere.check_inclusion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Sphere.check_inclusion" title="Permalink to this definition">¶</a></dt>
<dd><p>count how many points in the array p are included in the sphere.</p>
<p>overloading of superclass function, which is slower (here we can use the ellipsoid functional form to speed up things)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>p</strong> &#8211; list of points (numpy array)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">quantity of points located inside the sphere</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="convex.Sphere.get_sphericity">
<code class="descname">get_sphericity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Sphere.get_sphericity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Sphere.get_sphericity" title="Permalink to this definition">¶</a></dt>
<dd><p>compute sphericity (makes sense only for squeezed spheres, obviusly..)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">shape sphericity</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="convex.Sphere.get_surface">
<code class="descname">get_surface</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Sphere.get_surface"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Sphere.get_surface" title="Permalink to this definition">¶</a></dt>
<dd><p>compute sphere surface.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">surface in A^2</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="convex.Sphere.get_volume">
<code class="descname">get_volume</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Sphere.get_volume"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Sphere.get_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>compute ellipsoid volume.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">volume in A^3</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="convex.Sphere.squeeze">
<code class="descname">squeeze</code><span class="sig-paren">(</span><em>deformation</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/convex.html#Sphere.squeeze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#convex.Sphere.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>squeeze sphere according to deformation coefficient, keeping volume (approximately) constant</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>deformation</strong> &#8211; coefficient (scales x coordinates, and corrects on y coordinate)</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-density">
<span id="density"></span><h2>Density<a class="headerlink" href="#module-density" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="density.Density">
<em class="property">class </em><code class="descname">Density</code><a class="reference internal" href="_modules/density.html#Density"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#density.Density" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">biobox.classes.structure.Structure</span></code></p>
<p>Subclass of <a class="reference internal" href="#structure.Structure" title="structure.Structure"><code class="xref py py-func docutils literal"><span class="pre">Structure</span></code></a>, allows importing density map, and transform them in a PDB file containing a collection of spheres placed on the map&#8217;s high density regions.</p>
<p>A density map is fully described by the following attributes, stored in the self.properties dictionary:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>density</strong> &#8211; density map</li>
<li><strong>delta</strong> &#8211; scaling factor for voxels (default is [1, 1, 1] Angstrom)</li>
<li><strong>size</strong> &#8211; dimensions in voxels</li>
<li><strong>origin</strong> &#8211; bottom-left-front corner of the cube</li>
<li><strong>radius</strong> &#8211; radius of points composing the density map</li>
<li><strong>format</strong> &#8211; format name (only dx supported at the moment)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="density.Density.best_threshold">
<code class="descname">best_threshold</code><span class="sig-paren">(</span><em>mass</em>, <em>density=0.782878356</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/density.html#Density.best_threshold"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#density.Density.best_threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>If mass and density of object are known, try to filter the map so that the mass is best matched.</p>
<p>search for best threshold using bissection method.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">in proteins, an average value of 1.3 g/cm^3 (0.782878356 Da/A^3) can be assumed. Alternatively, the relation density=1.410+0.145*exp(-mass(kDa)/13) can be used.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">1 Da/A^3=0.602214120 g/cm^3mod2_WT_roomtemp_emd_2289.mrc</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mass</strong> &#8211; target mass in Da</li>
<li><strong>density</strong> &#8211; target density in Da/A^3</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">array reporting tested values and error on mass ([sigma, model_mass-target_mass])</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="density.Density.blur">
<code class="descname">blur</code><span class="sig-paren">(</span><em>dimension=5</em>, <em>sigma=0.5</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/density.html#Density.blur"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#density.Density.blur" title="Permalink to this definition">¶</a></dt>
<dd><p>blur density applying a cubic gaussian kernel of given kernel dimension (cubic grid size).</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">cannot be undone</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dimension</strong> &#8211; size of the kernel grid.</li>
<li><strong>sigma</strong> &#8211; standard deviation of gaussian kernel.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="density.Density.export_as_pdb">
<code class="descname">export_as_pdb</code><span class="sig-paren">(</span><em>outname</em>, <em>step</em>, <em>threshold=0.1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/density.html#Density.export_as_pdb"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#density.Density.export_as_pdb" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a pdb file with points where the density exceeds a threshold</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>outname</strong> &#8211; output file name</li>
<li><strong>step</strong> &#8211; stepsize used to generate the density map</li>
<li><strong>threshold</strong> &#8211; density to be exceeded to generate a point in pdb</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="density.Density.find_data_from_ccs">
<code class="descname">find_data_from_ccs</code><span class="sig-paren">(</span><em>ccs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/density.html#Density.find_data_from_ccs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#density.Density.find_data_from_ccs" title="Permalink to this definition">¶</a></dt>
<dd><p>map experimental data to given ccs</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>ccs</strong> &#8211; target CCS (in A^2)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="density.Density.find_data_from_sigma">
<code class="descname">find_data_from_sigma</code><span class="sig-paren">(</span><em>sigma</em>, <em>exact=True</em>, <em>append=False</em>, <em>noise_filter=0.01</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/density.html#Density.find_data_from_sigma"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#density.Density.find_data_from_sigma" title="Permalink to this definition">¶</a></dt>
<dd><p>map experimental data to given threshold</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sigma</strong> &#8211; density threshold</li>
<li><strong>noise_filter</strong> &#8211; launch DBSCAN clustering algorithm to detect connected regions in density map. Regions representing less than noise_filter of the total will be removed. This is a ratio, value should be between 0 and 1.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="density.Density.find_data_from_volume">
<code class="descname">find_data_from_volume</code><span class="sig-paren">(</span><em>vol</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/density.html#Density.find_data_from_volume"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#density.Density.find_data_from_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>map experimental data to given volume</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>vol</strong> &#8211; volume</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="density.Density.get_oversampled_points">
<code class="descname">get_oversampled_points</code><span class="sig-paren">(</span><em>sigma=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/density.html#Density.get_oversampled_points"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#density.Density.get_oversampled_points" title="Permalink to this definition">¶</a></dt>
<dd><p>return points obtained by oversampling the map (doule points on every axis)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sigma</strong> &#8211; place points only on voxels having intensity greater than threshold</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">points 3D points placed on voxels having value higher than threshold</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">radius radius of produced points</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="density.Density.get_sigma_from_thresh">
<code class="descname">get_sigma_from_thresh</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/density.html#Density.get_sigma_from_thresh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#density.Density.get_sigma_from_thresh" title="Permalink to this definition">¶</a></dt>
<dd><p>convert cutoff value from actual threshold to sigma multiple</p>
<p>:param threshold value
:returns sigma multiple</p>
</dd></dl>

<dl class="method">
<dt id="density.Density.get_thresh_from_sigma">
<code class="descname">get_thresh_from_sigma</code><span class="sig-paren">(</span><em>val</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/density.html#Density.get_thresh_from_sigma"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#density.Density.get_thresh_from_sigma" title="Permalink to this definition">¶</a></dt>
<dd><p>convert cutoff value from sigma multiples into actual threshold</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>val</strong> &#8211; sigma scaling</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">cutoff</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="density.Density.get_volume">
<code class="descname">get_volume</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/density.html#Density.get_volume"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#density.Density.get_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>compute density map volume. This is done by counting the points, and multiplying that by voxels&#8217; volume.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">can be called only after <a class="reference internal" href="#density.Density.place_points" title="density.Density.place_points"><code class="xref py py-func docutils literal"><span class="pre">place_points</span></code></a> has been called.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">supposes unskewed voxels.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="density.Density.import_map">
<code class="descname">import_map</code><span class="sig-paren">(</span><em>filename</em>, <em>fileformat='dx'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/density.html#Density.import_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#density.Density.import_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Import density map and fill up the points and properties data structures.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> &#8211; name of density file to load</li>
<li><strong>fileformat</strong> &#8211; at the moment supports dx, ccp4, mrc and imod</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="density.Density.import_numpy">
<code class="descname">import_numpy</code><span class="sig-paren">(</span><em>data, origin=[0, 0, 0], delta=array([[ 1.,  0.,  0.],        [ 0.,  1.,  0.],        [ 0.,  0.,  1.]])</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/density.html#Density.import_numpy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#density.Density.import_numpy" title="Permalink to this definition">¶</a></dt>
<dd><p>import a numpy 3D array to allow manipulation as a density map</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> &#8211; numpy 3D array</li>
<li><strong>origin</strong> &#8211; coordinates of bottom left corner of the map</li>
<li><strong>delta</strong> &#8211; voxels&#8217; shape (default is a cubic voxel of 1 Angstrom-long sides).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="density.Density.place_points">
<code class="descname">place_points</code><span class="sig-paren">(</span><em>sigma=0</em>, <em>noise_filter=0.01</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/density.html#Density.place_points"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#density.Density.place_points" title="Permalink to this definition">¶</a></dt>
<dd><p>given density information, place points on every voxel above a given threshold.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sigma</strong> &#8211; intensity threshold value.</li>
<li><strong>noise_filter</strong> &#8211; launch DBSCAN clustering algorithm to detect connected regions in density map. Regions representing less than noise_filter of the total will be removed. This is a ratio, value should be between 0 and 1.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="density.Density.return_density_map">
<code class="descname">return_density_map</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/density.html#Density.return_density_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#density.Density.return_density_map" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">density map as 3D numpy array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="density.Density.scan_threshold">
<code class="descname">scan_threshold</code><span class="sig-paren">(</span><em>mass</em>, <em>density=0.782878356</em>, <em>sampling_points=1000</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/density.html#Density.scan_threshold"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#density.Density.scan_threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>if mass and density of object are known, filter the map on a linear scale of threshold values, and compare the obtained mass to the experimental one.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">in proteins, an average value of 1.3 g/cm^3 (0.782878356 Da/A^3) can be assumed. Alternatively, the relation density=1.410+0.145*exp(-mass(kDa)/13) can be used.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">1 Da/A^3=0.602214120 g/cm^3</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mass</strong> &#8211; target mass in Da</li>
<li><strong>density</strong> &#8211; target density in Da/A^3</li>
<li><strong>sampling_points</strong> &#8211; number of measures to perform between min and max intensity in density map</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">array reporting tested values and error on mass ([threshold, model_mass-target_mass])</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="density.Density.threshold_vol_ccs">
<code class="descname">threshold_vol_ccs</code><span class="sig-paren">(</span><em>low=''</em>, <em>high=''</em>, <em>sampling_points=1000</em>, <em>append=False</em>, <em>noise_filter=0.01</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/density.html#Density.threshold_vol_ccs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#density.Density.threshold_vol_ccs" title="Permalink to this definition">¶</a></dt>
<dd><p>return the volume to threshold to CCS relationship</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sampling_points</strong> &#8211; number of measures to perform between min and max intensity in density map</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">array reporting tested values and error on mass ([threshold, model_mass-target_mass])</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="density.Density.write_dx">
<code class="descname">write_dx</code><span class="sig-paren">(</span><em>fname='dens.dx'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/density.html#Density.write_dx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#density.Density.write_dx" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a density map in DX format</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>fname</strong> &#8211; output file name</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Single Structures</a><ul>
<li><a class="reference internal" href="#module-structure">Structure</a></li>
<li><a class="reference internal" href="#module-molecule">Molecule</a></li>
<li><a class="reference internal" href="#convex-point-clouds">Convex Point Clouds</a></li>
<li><a class="reference internal" href="#module-density">Density</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">BiobOx&#8217;s documentation</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="assembly.html"
                        title="next chapter">Assemblies</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/structure.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="assembly.html" title="Assemblies"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="BiobOx’s documentation"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">biobox 1.0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Matteo Degiacomi.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.1.
    </div>
  </body>
</html>